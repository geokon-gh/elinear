<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Linear Systems in Lisp</title>
<!-- 2017-12-26 Tue 21:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="George Kontsevich" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://geokon-gh.github.io/static/worg.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linear Systems in Lisp</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Preface</a></li>
<li><a href="#sec-2">Systems of linear equations</a>
<ul>
<li><a href="#sec-2-1">A farming problem</a></li>
</ul>
</li>
<li><a href="#sec-3">Matices as representations of linear systems</a>
<ul>
<li><a href="#sec-3-1">The Matrix in the computer</a>
<ul>
<li><a href="#sec-3-1-1">Some helpers</a></li>
</ul>
</li>
<li><a href="#sec-3-2">Transposition: Getting the other equivalent matrix</a></li>
</ul>
</li>
<li><a href="#sec-4">Representing the whole system of equations</a>
<ul>
<li><a href="#sec-4-1">Matrix Multiplication</a>
<ul>
<li><a href="#sec-4-1-1">Inner Product</a></li>
<li><a href="#sec-4-1-2">Submatrices</a></li>
<li><a href="#sec-4-1-3">Matrix Product</a></li>
<li><a href="#sec-4-1-4">Matrix Conformability</a></li>
<li><a href="#sec-4-1-5">Addendum: Scalar Product</a></li>
</ul>
</li>
<li><a href="#sec-4-2">A system of equations as matrix product</a>
<ul>
<li><a href="#sec-4-2-1">The mirror universe</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Chaining problems through matrix composition</a>
<ul>
<li><a href="#sec-4-3-1">Taxing our farmers</a></li>
<li><a href="#sec-4-3-2">EXAMPLE: Geometrical transformations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">Equivalent matrices</a>
<ul>
<li><a href="#sec-5-1">Identity Matrix</a></li>
<li><a href="#sec-5-2">Unit Column/Rows</a></li>
<li><a href="#sec-5-3">Addition</a></li>
<li><a href="#sec-5-4">Elementary Matrices</a>
<ul>
<li><a href="#sec-5-4-1">Type I - Row/Column Interchange</a></li>
<li><a href="#sec-5-4-2">Type II - Row/Column Multiple</a></li>
<li><a href="#sec-5-4-3">Type III - Row/Column Addition</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">The LU Decomposition - Gaussian elimination in matrix form</a>
<ul>
<li><a href="#sec-6-1">Elementary Lower Triangular</a></li>
<li><a href="#sec-6-2">Partial Pivoting</a></li>
<li><a href="#sec-6-3">Gaussian Elimination</a></li>
<li><a href="#sec-6-4">Extracting the pivots</a></li>
</ul>
</li>
<li><a href="#sec-7">TODOs</a></li>
<li><a href="#sec-8">End</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Preface</h2>
<div class="outline-text-2" id="text-1">
<p>
This text is primarily my personal notes on linear algebra as I go through <i>Matrix Analysis &amp; Applied Linear Algebra</i>. At the same time this document is a literate program that can be executed in Emacs so the text will be slowly building up a linear algebra library of sorts. This will often not match the order things are presented in the book. There is no emphasis on performance - just on clarity, extensability and correctness when possible. This is purely (self)educational with my primary motivation being to help me better understand what I learn (through having to explain it) and to sanity check with actual programs. Things that are adequately explained in the book will not be repeated here.
</p>

<p>
This is my first program in Elisp, so if you see any issues, please leave a note in the <a href="https://github.com/geokon-gh/linearsystems/issues">issues</a> tab of <a href="https://github.com/geokon-gh/linearsystems/">the repository</a>. There you can also find the original org-mode file and the generated elisp files - both of which have additional unit-tests ommited from this webpage.
</p>

<p>
This is very much a work in progress and will change often&#x2026;
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Systems of linear equations</h2>
<div class="outline-text-2" id="text-2">
<p>
The book's opening problem from ancient China of calculating the price of bushels of crop serves as a good example of a linear problem. I've simplified the problem a bit for clarity - but I will expand on it and refer back to it extensively:
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">A farming problem</h3>
<div class="outline-text-3" id="text-2-1">
<blockquote>
<p>
You have a 3 fruit farms in a region of ancient China. In a given year:
</p>

<p>
<b>Given 1:</b><br  />
Farm 1 produces 3 tons of apples 2 ton of  oranges and 1 ton  of lemons<br  />
Farm 2 produces 2 tons of apples 3 tons of oranges and 1 ton  of lemons<br  />
Farm 3 produces 1 ton  of apples 2 tons of oranges and 3 tons of lemons<br  />
</p>

<p>
<b>Given 2:</b><br  />
Farm 1 sold its fruit for 39 yuan<br  />
Farm 2 sold its fruit for 34 yuan<br  />
Farm 3 sold its fruit for 26 yuan<br  />
</p>

<p>
What is the price of the a ton of apples/oranges/lemons?
</p>
</blockquote>
<p>
This is a familiar problem that can be restated as a system of linear equations
</p>

\begin{equation}
\begin{split}
3x+2y+z = 39\\
2x+3y+z = 34\\
x+ 2y + 3z = 26
\end{split}
\end{equation}

<p>
Where <code>x</code>, <code>y</code> and <code>z</code> represent <code>apples</code> <code>oranges</code> and <code>lemons</code> respectively
</p>

<p>
We know how to solve this system by manipulating the equations, solving for a variable and then back-substituting the results.
</p>

<p>
It's not accident I split up the problem into two sets of <b>Givens</b>. It's important to note that the problem actually has two distinct and independent parts. There is the farm/crop <b>linear system</b> (<code>Given 1</code>), and then there is the <b>constraint</b> of the profits of each farm (<code>Given 2</code>)
</p>

<p>
We are looking for the input fruit-prices that will yield the given profits for each farm
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Matices as representations of linear systems</h2>
<div class="outline-text-2" id="text-3">
<p>
The <b>linear system</b> can be represented with a matrix
</p>

\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 1\\
1 & 2 & 3\\
\end{bmatrix}

<p>
or flipped::
</p>

\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 2\\
1 & 1 & 3\\
\end{bmatrix}

<p>
We prefer the first representation, but both ways work as long as you remember what each row and column represents
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">The Matrix in the computer</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Once we've chosen a layout the easiest way to store the matrix in the computer is to remember 3 values: <code>number-of-rows</code> <code>number-of-columns</code> <code>data</code>
</p>

<p>
The <code>data</code> value will be a long list of size <code>num-row * num-col</code> that contains all the values of the matrix; row after row. So given a list <code>data</code> and a pair of sizes we simply build the matrix into a list of these three values: 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-from-data-list</span> (number-of-rows number-of-columns data-list)
  <span style="color: #cc0000;">"Builds a matrix from a data list"</span>
  (list 
   number-of-rows 
   number-of-columns 
   data-list))
</pre>
</div>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Some helpers</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
With a couple of helper function we can get back these 3 fields. This will improve the readability of the code as we go along
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-rows</span> (matrix)
  <span style="color: #cc0000;">"Get the number of rows"</span>
  (nth 0 matrix))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-columns</span> (matrix)
  <span style="color: #cc0000;">"Get the number of columns"</span>
  (nth 1 matrix))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-data</span> (matrix)
  <span style="color: #cc0000;">"Get the data list from the matrix"</span>
  (nth 2 matrix))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-get-value</span> (matrix row column)
  <span style="color: #cc0000;">"Get the scalar value at position ROW COLUMN (ZERO indexed) from MATRIX"</span>
  (nth
   (+
    column
    (*
     row
     (matrix-columns matrix)))
    (matrix-data matrix)))
</pre>
</div>
<blockquote>
<p>
<code>nth</code> gets the nth element of the list
</p>
</blockquote>
<p>
For debugging and looking at results we also need to be able to print out the matrix for inspection
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-data-get-first-n-values</span> (data n)
  <span style="color: #cc0000;">"Given a list of values, get the first n in a string"</span>
  (<span style="color: #00af00;">if</span> (zerop n)
      <span style="color: #ff1f8b;">""</span> <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">base case</span>
    (concat
     (number-to-string (car data))
     <span style="color: #ff1f8b;">" "</span>
     (matrix-data-get-first-n-values (cdr data) (1- n))))) <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">iterative step</span>

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-data-print</span> (number-of-rows number-of-columns data)
  <span style="color: #cc0000;">"Print out the data list gives the dimension of the original matrix"</span>
  (<span style="color: #00af00;">if</span> (zerop number-of-rows)
      <span style="color: #ff1f8b;">""</span> <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">base case</span>
    (concat
     (matrix-data-get-first-n-values data number-of-columns)
     <span style="color: #ff1f8b;">"\n"</span>
     (matrix-data-print <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">iterative step</span>
      (1- number-of-rows)
      number-of-columns
      (nthcdr number-of-columns data )))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-print</span> (matrix)
  <span style="color: #cc0000;">"Print out the matrix"</span>
  (concat <span style="color: #ff1f8b;">"\n"</span> (matrix-data-print
                (matrix-rows matrix)
                (matrix-columns matrix)
                (matrix-data matrix))))
<span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">ex:  (message (matrix-print (matrix-from-data-list 2 2 '(1 2 3 4))))</span>
</pre>
</div>
<blockquote>
<p>
<code>zerop</code> tests if the value is zero
</p>
</blockquote>
<blockquote>
<p>
<code>()</code> with a quote is the <i>empty-list</i> 
</p>
</blockquote>
<blockquote>
<p>
<code>cons</code> attaches the first argument to the second argument (which is normally a list)
</p>
</blockquote>
<blockquote>
<p>
<code>cdr</code> returns the list without the first element
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Transposition: Getting the other equivalent matrix</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Since we have two equivalent matrices that represent our linear system we need a mechanism to go from one to the other. This method is the matrix transpose which flips the matrix along the diagonal. The text goes into depth on the properties of the matrix transpose, but in short, as long as you take the transpose of both sides of your equations equivalances will be preserved.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-transpose</span> (matrix)
  <span style="color: #cc0000;">"Get the transpose of a matrix"</span>
  (<span style="color: #00af00;">if</span> (equal (matrix-columns matrix) 1)
    (matrix-from-data-list
     1
     (matrix-rows matrix)
     (matrix-data matrix))
    (matrix-append
     (matrix-from-data-list
      1
      (matrix-rows matrix)
      (matrix-data (matrix-get-column matrix 0)))
     (matrix-transpose
      (matrix-submatrix
       matrix
       0
       1
       (matrix-rows matrix)
       (matrix-columns matrix))))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Representing the whole system of equations</h2>
<div class="outline-text-2" id="text-4">
<p>
Now that we can represent the fruit/profits system we want a mechanism to represent the whole system of equations so that given a constraint, we can solve for a solution.
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Matrix Multiplication</h3>
<div class="outline-text-3" id="text-4-1">
<p>
This is done notationally with matrix multiplication. The notation allows us to keep the two <b>Givens</b> separated and allows us to visually chain linear systems together. As a shorthand, we write the product of two matrices <code>A</code> and <code>B</code> as <code>AB = C</code>, with the order of <code>A</code> and <code>B</code> being important. For every value (at a given row and column position) in the resulting matrix <code>C</code> we take the equivalent row in <code>A</code> and multiply it by its equivalent column in <code>B</code>. From this we can conclude that <code>C</code> will have as many rows as <code>A</code> and as many column as <code>B</code>
</p>

<p>
Multiplying a row times a column is called an <code>inner product</code>
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">Inner Product</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
The <code>inner-product</code> is defined as the sum of the product of every pair of equivalent elements in the two vectors. The sum will naturally return one scalar value. This operation only makes sense if both the row and column have the same number of values.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-inner-product</span> (row column)
  <span style="color: #cc0000;">"Multiply a row times a column and returns a scalar"</span>
  (reduce
   '+
   (for-each-pair
    (matrix-data row)
    (matrix-data column)
    '*)))
</pre>
</div>
<blockquote>
<p>
<code>reduce</code> works down the list elements-by-element applying the operator on each cumulative result
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">Submatrices</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
To get rows and columns (and other submatrices) we need a few more helper functions
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-extract-subrow</span> (matrix row start-column end-column)
  <span style="color: #cc0000;">"Get part of a row of a matrix and generate a row matrix from it. START-COLUMN is inclusive,  END-COLUMN is exclusive"</span>
  (<span style="color: #00af00;">let</span>
      ((number-of-columns-on-input (matrix-columns matrix))
       (number-of-columns-on-output (-
                                     end-column 
                                     start-column)))
    (matrix-from-data-list
     1
     number-of-columns-on-output
     (subseq
      (matrix-data matrix)
      (+ (* row number-of-columns-on-input) start-column)
      (+ (* row number-of-columns-on-input) end-column)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-append</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Append one matrix (set of linear equations) to another"</span>
  (<span style="color: #00af00;">if</span> (null matrix2)
      matrix1
    (matrix-from-data-list
     (+
      (matrix-rows matrix2)
      (matrix-rows matrix1))
     (matrix-columns matrix1)
     (append
      (matrix-data matrix1)
      (matrix-data matrix2)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-submatrix</span> (matrix start-row start-column end-row end-column)
  <span style="color: #cc0000;">"Get a submatrix. start-row/column are inclusive. end-row/column are exclusive"</span>
  (<span style="color: #00af00;">if</span> (equal start-row end-row)
      '()
    (matrix-append
     (matrix-extract-subrow matrix start-row start-column end-column)
     (matrix-submatrix
      matrix
      (1+ start-row)
      start-column
      end-row
      end-column))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-get-row</span> (matrix row)
  <span style="color: #cc0000;">"Get a row from a matrix. Index starts are ZERO"</span>
  (matrix-extract-subrow
   matrix
   row
   0
   (matrix-columns matrix)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-get-column</span> (matrix column)
  <span style="color: #cc0000;">"Get a column from a matrix. Index starts are ZERO"</span>
  (matrix-submatrix
   matrix
   0
   column
   (nth 0 matrix)
   (1+ column)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">Matrix Product</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Now we have all the tools we need to write down the algorithm for calculating the matrix product. First we write a function to calculate the product for one value at a given position
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-product-one-value</span> (matrix1 matrix2 row column)
  <span style="color: #cc0000;">"Calculate one value in the resulting matrix of the product of two matrices"</span>
  (matrix-inner-product
   (matrix-get-row matrix1 row )
   (matrix-get-column matrix2 column)))
</pre>
</div>
<p>
And then we recursively apply it to construct the resulting matrix
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-product</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Multiply two matrices"</span>

  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-product-rec</span> (matrix1 matrix2 row column)
    <span style="color: #cc0000;">"A recursive helper function that builds the matrix multiplication's data vector"</span>
    (<span style="color: #00af00;">if</span> (equal (matrix-rows matrix1) row)
        '()
      (<span style="color: #00af00;">if</span> (equal (matrix-columns matrix2) column)
          (matrix-product-rec
           matrix1
           matrix2
           (1+ row)
           0)
        (cons
         (matrix-product-one-value
          matrix1
          matrix2
          row column)
         (matrix-product-rec
          matrix1
          matrix2
          row
          (1+ column))))))

  (matrix-from-data-list
   (matrix-rows matrix1)
   (matrix-columns matrix2)
   (matrix-product-rec
    matrix1
    matrix2
    0
    0)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">Matrix Conformability</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
You will notice that the algorithm won't make sense if the number of columns of <code>A</code> doesn't match the number of rows of <code>B</code>. When the values match the matrices are called <b>conformable</b>. When they <i>don't</i> match you will see that inner product isn't defined and therefore neither is the product.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-conformable?</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Check that two matrices can be multiplied"</span>
  (equal
   (matrix-columns matrix1)
   (matrix-rows matrix2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5">Addendum: Scalar Product</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
An additional form of matrix multiplication is between a matrix and a scalar. Here we simply multiply each element of the matrix times the scalar to construct the resulting matrix. The order of multiplication is not important -&gt; <b>&alpha;A=A&alpha;</b>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-scalar-product</span> (matrix scalar)
  <span style="color: #cc0000;">"Multiple the matrix by a scalar. ie. multiply each value by the scalar"</span>
  (matrix-from-data-list
   (matrix-rows matrix)
   (matrix-columns matrix)
   (mapcar
   (<span style="color: #00af00;">lambda</span> (x) 
     (* scalar x))
   (matrix-data matrix))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">A system of equations as matrix product</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now that we have all our tools we can write down a matrix product that will mimic our system of equation.
</p>

\begin{equation}
\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 1\\
1 & 2 & 3\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}
=
\begin{bmatrix}
39\\
34\\
26\\
\end{bmatrix}
\end{equation}

<p>
Going through our algorithm manually we see that the resulting matrix is:
</p>

\begin{equation}
\begin{bmatrix}
3x + 2y + z\\
2x + 3y + z\\
x + 2y + 3z\\
\end{bmatrix}
=
\begin{bmatrix}
39\\
34\\
26\\
\end{bmatrix}
\end{equation}
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">The mirror universe</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Now I said that flipped matrix was also a valid representation. We can confirm this by taking the transpose of both sides 
</p>


\begin{equation}
\begin{bmatrix}
x & y & z\\
\end{bmatrix}
\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 2\\
1 & 1 & 3\\
\end{bmatrix}
=
\begin{bmatrix}
39 & 34 & 26\\
\end{bmatrix}
\end{equation}


<p>
It yields another matrix product that mimics the equations, however you'll see in the textbook that we always prefer the first notation.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Chaining problems through matrix composition</h3>
<div class="outline-text-3" id="text-4-3">
<p>
The real power of matrix multiplication is in its ability to chain systems together through <b>linear composition</b>
</p>

<p>
If we are given a new problem that take the output of our first system and produces a new output - composition gives us a mechanism to combine the systems into one.
</p>
</div>

<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Taxing our farmers</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
Say the imperial palace has a system for collecting taxes
</p>
<blockquote>
<p>
<b>Given</b>:<br  />
The farms have to pay a percentage of their income to different regional governements. The breakdown is as follows:<br  />
The town taxes Farm 1 at 5%, Farm 2 at 3%, Farm 3 at 7%<br  />
The province taxes all Farm 1 at 2% Farm 2 at 4%, Farm 3 at 2%<br  />
The palace taxes all farms at 7%
</p>
</blockquote>
<p>
Now, given the income of each farm <b>i</b> we can build a new matrix <b>B</b> and calculate the tax revenue of each government - <b>t</b>.<br  />
</p>

\begin{equation}
Bi=t
\end{equation}

<p>
From the previous problem we know that the income of each farm was already a system of equation with the price of fruit as input <b>f</b><br  />
</p>

\begin{equation}
Af=i
\end{equation}

<p>
So we just plug one into the other and get<br  />
</p>
\begin{equation}
B(Af)=t
\end{equation}

<p>
and compose a new equation that given the price of fruit gives us the regional tax revenue. By carrying out the product we can generate one linear system<br  />
</p>

\begin{equation}
(BA)f=t\\
\end{equation} 
<p>
Where if <b>BA=C</b> the final composed system is:
</p>
\begin{equation}
Cf=t
\end{equation} 
<p>
Note that the rows of <b>BA</b> are the combination of the rows of <b>A</b> and the columns of <b>BA</b> are the combination of the columns of <b>B</b> - at the same time! (see page 98)
</p>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">EXAMPLE: Geometrical transformations</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
A very simple example are the linear systems that takes coordinates <i>x y</i> and do transformations on them
</p>

<p>
<b>Rotation</b>
</p>
\begin{equation}
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
=
\begin{bmatrix}
x_{rotated}\\
y_{rotated}\\
\end{bmatrix}
\end{equation}

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-rotate-2D</span> (radians)
  <span style="color: #cc0000;">"Generate a matrix that will rotates a [x y] column vector by RADIANS"</span>
  (matrix-from-data-list
   2
   2
   (list
     (cos radians)
     (- (sin radians))
     (sin radians)
     (cos radians))))
</pre>
</div>
<p>
<b>Reflection about X-Axis</b>
</p>
\begin{equation}
\begin{bmatrix}
1 & 0 \\
0 & -1\\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
=
\begin{bmatrix}
x_{reflected}\\
y_{reflected}\\
\end{bmatrix}
\end{equation}

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-reflect-around-x-2D</span> ()
  <span style="color: #cc0000;">"Generate a matrix that will reflect a [x y] column vector around the x axis"</span>
  (matrix-from-data-list
   2
   2
   '(1 0 0 -1)))
</pre>
</div>
<p>
<b>Projection on line</b>
</p>
\begin{equation}
\begin{bmatrix}
1/2 & 1/2 \\
1/2 & 1/2\\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
=
\begin{bmatrix}
x_{projected}\\
y_{projected}\\
\end{bmatrix}
\end{equation}

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-project-on-x=y-diagonal-2D</span> ()
  <span style="color: #cc0000;">"Generate a matrix that projects a point ([x y] column vector) onto a line (defined w/ a unit-vector)"</span>
  (matrix-from-data-list
   2
   2
   '(0.5 0.5 0.5 0.5)))
</pre>
</div>
<p>
So given a point <i>[x y]</i> (represented by the column vector <b>v</b>) we can use these 3 transformation matrices to move it around our 2D space. We simple write a chain of transformations <b>T</b> and multiply them times the given vector <b>T<sub>1</sub>T<sub>2</sub>T<sub>3</sub>v=v<sub>new</sub></b>. These transformation matrices can then be multiplied together into one that will carry out the transformation in one matrix product. <b>T<sub>1</sub>T<sub>2</sub>T<sub>3</sub>=T<sub>total</sub></b> =&gt; <b>T<sub>total</sub>v=v<sub>new</sub></b> 
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Equivalent matrices</h2>
<div class="outline-text-2" id="text-5">
<p>
Now thanks to matrix multiplication we can represent linear systems and we can chain them together. The next step is extending multiplication to represent general manipulations of matrices.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Identity Matrix</h3>
<div class="outline-text-3" id="text-5-1">
<p>
For any matrix <b>A</b>, the identity matrix <b>I</b> is such that <b>A*I</b> = <b>A</b> = <b>I*A</b>. Given the dimensions, <b>I</b> has to be a square matrix. It will have <b>1</b>'s on the diagonal (ie. where <code>row==column</code>) and zeroes everywhere else. We build it recursively:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-identity</span> (rank)
  <span style="color: #cc0000;">"Build an identity matrix of the given size/rank"</span>

  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-build-identity-rec</span> (rank row column)
    <span style="color: #cc0000;">"Helper function that build the data vector of the identity matrix"</span>
    (<span style="color: #00af00;">if</span> (equal column rank) <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">time to build next row</span>
        (<span style="color: #00af00;">if</span> (equal row (1- rank))
            '() <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">we're done</span>
          (matrix-build-identity-rec
           rank
           (1+ row)
           0))
      (<span style="color: #00af00;">if</span> (equal row column)
          (cons
           1
           (matrix-build-identity-rec
            rank
            row
            (1+ column)))
        (cons
         0
         (matrix-build-identity-rec
          rank
          row
          (1+ column))))))

  (matrix-from-data-list rank rank (matrix-build-identity-rec rank 0 0 )))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Unit Column/Rows</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Each column of the <b>identity matrix</b> is a unit column (denoted as <b>e<sub><i>j</i></sub></b>). It contains a <b>1</b> in a given postion (here: <i>j</i>) and <b>0s</b> everwhere else. Its transpose is naturally called the <b>unit row</b><br  />
<b>Ae<sub><i>j</i></sub></b> = the <i>j</i> column of A<br  />
<b>e<sub><i>i</i></sub><sup>T</sup>A</b> = the <i>i</i> row of A<br  />
<b>e<sub><i>i</i></sub><sup>T</sup>Ae<sub><i>j</i></sub></b> = gets the [ <i>i</i>, <i>j</i> ] element in A
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-unit-rowcol-data</span> (index size)
<span style="color: #cc0000;">"Create a data-list for a matrix row/column. INDEX (starts at ZERO) matches the row or column where you want a 1. SIZE is the overall size of the vector"</span>
(<span style="color: #00af00;">if</span> (zerop size)
    '()
  (<span style="color: #00af00;">if</span> (zerop index)
      (cons
       1
       (matrix-unit-rowcol-data
        (1- index)
        (1- size)))
    (cons
     0
     (matrix-unit-rowcol-data
      (1- index)
      (1- size))))))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-unit-column</span> (row size)
  <span style="color: #cc0000;">"Build a unit column. ROW is where you want the 1 to be placed (ZERO indexed). SIZE is the overall length"</span>
      (matrix-from-data-list
       size
       1
       (matrix-unit-rowcol-data
        row
        size)))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-unit-row</span> (column size)
  <span style="color: #cc0000;">"Build a unit column. COLUMN is where you want the 1 to be placed (ZERO indexed). SIZE is the overall length"</span>
      (matrix-from-data-list
       1
       size
       (matrix-unit-rowcol-data
        column
        size)))
</pre>
</div>
<blockquote>
<p>
Here I'm just trying out a new notation. With <code>letrec</code> we can hide the recursive helper function inside the function that uses it.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Addition</h3>
<div class="outline-text-3" id="text-5-3">
<p>
As a tool in building new matrices, we need a way to easily add two matrices, ie. add their values one to one. Matrices that are added need to have the same size.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-equal-size-p</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Check if 2 matrices are the same size"</span>
  (<span style="color: #00af00;">and</span>
   (equal
    (matrix-rows matrix1)
    (matrix-rows matrix2))
   (equal
    (matrix-columns matrix1)
    (matrix-columns matrix2))))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">for-each-pair</span> (list1 list2 operator)
  <span style="color: #cc0000;">"Go through 2 lists applying an operator on each pair of elements"</span>
  (<span style="color: #00af00;">if</span> (null list1)
      '()
    (cons
     (funcall operator (car list1) (car list2))
     (for-each-pair (cdr list1) (cdr list2) operator))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-add</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Add to matrices together"</span>
  (<span style="color: #00af00;">if</span> (matrix-equal-size-p matrix1 matrix2)
      (matrix-from-data-list
       (matrix-rows matrix1)
       (matrix-columns matrix1)
       (for-each-pair
        (matrix-data matrix1)
        (matrix-data matrix2)
        '+))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-subtract</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Subtract MATRIX2 from MATRIX1"</span>
  (<span style="color: #00af00;">if</span> (matrix-equal-size-p matrix1 matrix2)
      (matrix-from-data-list
       (matrix-rows matrix1)
       (matrix-columns matrix1)
       (for-each-pair
        (matrix-data matrix1)
        (matrix-data matrix2)
        '-))))
</pre>
</div>
<blockquote>
<p>
<code>funcall</code> applied the first arugment (a function) with the remaining items in the list as arguments
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Elementary Matrices</h3>
<div class="outline-text-3" id="text-5-4">
<p>
The manipulation of the rows and columns can be broken down into 3 types of <b>elementary matrices</b> that when multiplied with our <b>linear systems</b> will generate <b>equivalent</b> matrices (<b>E</b>). 
</p>

<p>
<i>(from page 134)</i>
When applied from the <i>left</i> <b>EA=B</b> it performs a row operation and makes a <b>row equivalent</b> matrix.<br  />
When applied from the <i>right</i> <b>AE=B</b> it performs a column operation and makes a <b>column equivalent</b> matrix.<br  />
</p>

<p>
Row/column operations are ofcourse reversible and therefore <b>E</b> is invertible and a <b>E<sup>-1</sup></b> always exists.
</p>

<p>
So now, waving our hands a little, given a non-singular matrix we can restate <i>Gauss-Jordan elimination</i> as "a bunch of row operations that turn our matrix into the identity matrix". Ie: <b>E<sub>k</sub>..E<sub>2</sub>E<sub>1</sub>A=I</b><br  />
And thanks to each operations' invertibility we can flip it to be <b>A=E<sub>1</sub><sup>-1</sup>E<sub>2</sub><sup>-1</sup>..E<sub>k</sub><sup>-1</sup></b><br  />
So Gauss-Jordan elimination for non-singular matrices has given us our first decomposition of sorts! We now know that every non-singular matrix can be written as a chain of row (or column) operations.
</p>

<p>
Row/Column operations come in 3 flavors
</p>
</div>
<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Type I - Row/Column Interchange</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Interchaning rows (or columns) <i>i</i> and <i>j</i>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-interchange</span> (rowcol1 rowcol2 rank)
  <span style="color: #cc0000;">"Make an elementary row/column interchange matrix for ROWCOL1 and ROWCOL2 (ZERO indexed)"</span>
  (<span style="color: #00af00;">let</span> ((u
         (matrix-subtract
          (matrix-unit-column rowcol1 rank)
          (matrix-unit-column rowcol2 rank))))
  (matrix-subtract
   (matrix-identity rank)
   (matrix-product
    u
    (matrix-transpose u)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-interchange-inverse</span> (rowcol1 rowcol2 rank)
  <span style="color: #cc0000;">"Make the inverse of the elementary row/column interchange matrix for ROWCOL1 and ROWCOL2 (ZERO indexed). This is identical to (matrix-elementary-interchange)"</span>
  (matrix-elementary-interchange
   rowcol1
   rowcol2
   rank))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Type II - Row/Column Multiple</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
Multiplying row (or column) <i>i</i> by <i>&alpha;</i>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-multiply</span> (rowcol scalar rank)
  <span style="color: #cc0000;">"Make an elementary row/column multiple matrix for a given ROWCOL (ZERO indexed)"</span>
  (<span style="color: #00af00;">let</span> ((elementary-column
         (matrix-unit-column rowcol rank)))
  (matrix-subtract
   (matrix-identity rank)
   (matrix-product
    elementary-column
    (matrix-scalar-product
     (matrix-transpose elementary-column)
     (- 1 scalar))))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-multiply-inverse</span> (rowcol scalar rank)
  <span style="color: #cc0000;">"Make the inverseof the elementary row/column multiple matrix for a given ROWCOL (ZERO indexed)"</span>
  (matrix-elementary-multiply
   rowcol
   (/ 1 scalar)
   rank))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Type III - Row/Column Addition</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
Adding a multiple of a row (or column) <i>i</i> to row (or column) <i>j</i>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-addition</span> (rowcol1 rowcol2 scalar rank)
  <span style="color: #cc0000;">"Make an elementary row/column product addition matrix. Multiply ROWCOL1 (ZERO indexed) by SCALAR and add it to ROWCOL2 (ZERO indexed)"</span>
  (matrix-add
   (matrix-identity rank)
   (matrix-scalar-product
    (matrix-product
     (matrix-unit-column rowcol2 rank)
     (matrix-transpose
      (matrix-unit-column rowcol1 rank)))
    scalar)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-addition-inverse</span> (rowcol1 rowcol2 scalar rank)
  <span style="color: #cc0000;">"Make the inverse of the elementary row/column product addition matrix. Multiply ROWCOL1 (ZERO indexed) by SCALAR and add it to ROWCOL2 (ZERO indexed)"</span>
  (matrix-elementary-addition
   rowcol1
   rowcol2
   (- scalar)
   rank))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">The LU Decomposition - Gaussian elimination in matrix form</h2>
<div class="outline-text-2" id="text-6">
<p>
Gaussian elimination is a systematic way for taking a known linear system with a given output and solving for it's input. The method reduces our linear equations (through combining and swapping equations) such that last equation ends reading something of the form <b>&alpha;z=b</b>. This simple equation we can easily solve for our last unknown input (<b>z=b/&alpha;</b>) and back substitute it in to solve for the remaining input values. When we manipulate our equations to eliminate values we are combining and interchanging rows and this applies equally to the linear system, the unknown inputs, and the known outputs - however the factors we are trying to eliminate are in the linear system only
</p>

<p>
So instead of dealing with the whole set of equation we can just concentrate on the linear sytem - in matrix form. Reducing the the matrix happens in exactly the same way and the resulting matrix will have in its last row all zeroes except for one value on the far right (which is equivalent to the above-mentioned <b>&alpha;</b>). We can save all the steps and apply them to any input and outputs later so that they are mixed properly as well. The real value is that we can now represent each step with our new <i>elementary matrices</i> 
</p>

<p>
Just like in Gaussian elimination and our linear equation, on a high level the reduction of the matrix happens in two repeated steps for each column. We adjust the pivot and then reduce all the values below it to zero.
</p>

<p>
<i>From the Example on page 141</i> <br  />
The process will take us from a matrix like:
</p>
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
<p>
To an <b>upper triangular</b> matrix <b>U</b>:
</p>
\begin{bmatrix}
2 & 2 & 1\\
0 & 3 & 3\\
0 & 0 & 4\\
\end{bmatrix}
<p>
As you can see the last row in the final matrix represents the previously mentioned trivial equation <b>&alpha;z=b</b> which we can use for backsubstitution. If each step of the reduction is <b>G<sub>x</sub></b> we can write the process as <b>G<sub>1</sub>G<sub>2</sub>G<sub>&#x2026;</sub>G<sub>n</sub>A=U</b>. Or for the full set of equations it will go from <b>Ax=b</b> to <b>G<sub>1</sub>G<sub>2</sub>G<sub>&#x2026;</sub>G<sub>n</sub>(Ax)=G<sub>1</sub>G<sub>2</sub>G<sub>&#x2026;</sub>G<sub>n</sub>b</b> which we can reduce to <b>Ux=G<sub>1</sub>G<sub>2</sub>G<sub>&#x2026;</sub>G<sub>n</sub>b</b>.
</p>

<blockquote>
<p>
<b>Note:</b> Gaussian elimination will only produce a solution for nonsingular square matrices, so the process described only holds for this case
</p>
</blockquote>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Elementary Lower Triangular</h3>
<div class="outline-text-3" id="text-6-1">
<p>
In the above example the first step was zeroing out the value below the <code>2</code> in the first column. We can accomplish that transformation by multiply the matrix by two <code>Type III</code> <b>elementary matrices</b>
</p>
\begin{bmatrix}
1 & 0 & 0\\
-2 & 1 & 0\\
0 & 0 & 1\\
\end{bmatrix}
<p>
and
</p>
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
-3 & 0 & 1\\
\end{bmatrix}
<p>
These are the <i>identity</i> matrix with some extra values. You can visually see what the <code>-2</code> and <code>-3</code> represent - They match to a corresponding entry in the orginal matrix divided by the value of the pivot (ie: the factor that will eliminate the value) After applying these matrixes on our starting matrix from the left (<b>G<sub>1</sub>G<sub>2</sub>A</b>) we end up with our desired result
</p>
\begin{bmatrix}
2 & 2 & 1\\
0 & 3 & 3\\
0 & 12 & 16\\
\end{bmatrix}
<p>
Constructing these simple <code>Type III</code> is quick
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-row-elimination</span> (matrix row column)
  <span style="color: #cc0000;">"Make a matrix that will eliminate an element at the specified ROW/COLUMN (ZERO indexed) using the diagonal element in the same column (typically the pivot)"</span>
  (<span style="color: #00af00;">let</span>
      ((pivot (matrix-get-value matrix column column))
       (element-to-eliminate (matrix-get-value matrix row column)))
    (matrix-elementary-addition
     column
     row
     (-
      (/
       element-to-eliminate
       pivot))
     (matrix-rows matrix))))
</pre>
</div>

<p>
Looking at the product of these 3 matrices - <b>G<sub>1</sub>G<sub>2</sub>A</b> - and based on what we know about composing linear systems we know that the elementary matrices can be combined into one <b>(G<sub>1</sub>G<sub>2</sub>)A=G<sub>all</sub>A</b> (where <b>G<sub>all</sub>=G<sub>1</sub>G<sub>2</sub></b>). If we try that here <b>G<sub>1</sub>G<sub>2</sub></b> gives us:
</p>
\begin{bmatrix}
1 & 0 & 0\\
-2 & 1 & 0\\
-3 & 0 & 1\\
\end{bmatrix}
<p>
You can see that we didn't really need to carry out the matrix product b/c we've simply merged the factors into one matrix. Combining these row reduction <code>Type III</code> matrices is mechanical and gives us the <b>Elementary Lower-Triangular Matrix</b> mentioned on page 142. Each column reduction to zeroes has an equivalent elementary lower-triangular matrix (so for a rank <b>r</b> matrix we will have to have <i>r</i> elementary low-triangular matrices)
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-lower-triangular</span> (matrix column-to-clear)
  <span style="color: #cc0000;">"Make a matrix that will eliminate all rows in a column below the diagonal (pivot position)"</span>

  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-lower-triangular-rec</span> (matrix column-to-clear row-to-build rank)
    <span style="color: #cc0000;">"Recursive function to build the elementary lower triangular matrix"</span>
    (<span style="color: #00af00;">cond</span>
     ((equal
       rank
       row-to-build) <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">Done building the matrix</span>
      '())
     ((&lt;=
       row-to-build
       column-to-clear) <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">Building the simply "identity" portion above the pivot</span>
      (matrix-append
       (matrix-unit-row row-to-build rank)
       (matrix-elementary-lower-triangular-rec
        matrix
        column-to-clear
        (1+ row-to-build)
        rank)))
     (t <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">Build the elimination portion below the pivot</span>
      (<span style="color: #00af00;">let</span>
          ((pivot (matrix-get-value matrix column-to-clear column-to-clear))
           (element-to-eliminate (matrix-get-value matrix row-to-build column-to-clear)))
        (<span style="color: #00af00;">let</span>
            ((cancellation-factor (-
                                   (/
                                    element-to-eliminate
                                    pivot))))
          (matrix-append
           (matrix-add
            (matrix-unit-row row-to-build rank)
            (matrix-scalar-product
             (matrix-unit-row column-to-clear rank)
             cancellation-factor))
           (matrix-elementary-lower-triangular-rec
            matrix
            column-to-clear
            (1+ row-to-build)
            rank)))))))

  (matrix-elementary-lower-triangular-rec
   matrix
   column-to-clear
   0
   (matrix-rows matrix)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Partial Pivoting</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The next step in Gaussian elimination is adjusting pivots. After we eliminate the values in column <i>n</i> we may end up with a zero on the diagonal pivot position in column <i>n+1</i>. We can do a simple swap with any row below when we see a zero (page 6) but we know that if each time we swap with the maximal value in the column through <b>partial pivoting</b> we will get a better numerical solution. This is a direct application of a <b>Type I</b> elementary matrix. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-partial-pivot</span> (matrix pivot-column)
    <span style="color: #cc0000;">"Adjust the pivot in the PIVOT-COLUMN to be have the maximal magnititude in that column"</span>
    (<span style="color: #00af00;">let</span> ((column-below-pivot (matrix-submatrix
                               matrix
                               pivot-column
                               pivot-column
                               (matrix-rows matrix)
                               (1+ pivot-column))))
      (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">find-max-index</span> (data-list max-val max-index current-index)
        (<span style="color: #00af00;">cond</span>
         ((null data-list)
          max-index)
         ((&gt;
           (abs(car data-list))
           max-val)
          (find-max-index
           (cdr data-list)
           (abs(car data-list))
           current-index
           (1+ current-index)))
         (t
          (find-max-index
           (cdr data-list)
           max-val
           max-index
           (1+ current-index)))))

     (matrix-elementary-interchange
      pivot-column
      (+
       pivot-column
       (find-max-index
        (matrix-data column-below-pivot)
        0
        0
        0))
      (matrix-rows matrix))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Gaussian Elimination</h3>
<div class="outline-text-3" id="text-6-3">
<p>
If <b>G<sub>n</sub></b> are the <i>elementary lower-triangular matrices</i> that clear the columns and <b>F<sub>n</sub></b> are the <b>Type I</b> pivot adjustments, then the steps compose into:  <b>G<sub>1</sub>F<sub>1</sub>G<sub>2</sub>F<sub>2</sub>..G<sub>r</sub>F<sub>r</sub>A</b> where you can pair up each elimination and pivot steps as they complete each column <b>(G<sub>1</sub>F<sub>1</sub>)<sub>col<sub>1</sub></sub>(G<sub>2</sub>F<sub>2</sub>)<sub>col<sub>2</sub></sub>..(G<sub>r</sub>F<sub>r</sub>)<sub>col<sub>r</sub></sub>A</b>. The result is the upper triangular matrix <b>U</b>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-to-upper-triangular</span> (matrix)
  <span style="color: #cc0000;">"Take the input MATRIX and use Gaussian elimination to make the upper triangular back-substitution matrix"</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-to-upper-triangular-rec</span> (matrix column-to-pivot-and-reduce)
    (<span style="color: #00af00;">cond</span>
     ((equal
       column-to-pivot-and-reduce
       (matrix-rows matrix))
      matrix)
     (t
      (<span style="color: #00af00;">let</span> 
          ((pivoted-matrix 
            (matrix-product <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">pivot!</span>
             (matrix-partial-pivot
              matrix
              column-to-pivot-and-reduce)
             matrix)))
        (matrix-to-upper-triangular-rec
         (matrix-product <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">reduce</span>
          (matrix-elementary-lower-triangular
           pivoted-matrix
           column-to-pivot-and-reduce)
          pivoted-matrix)
         (1+ column-to-pivot-and-reduce))))))
  (matrix-to-upper-triangular-rec matrix 0))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">Extracting the pivots</h3>
<div class="outline-text-3" id="text-6-4">
<p>
We have now completed Gaussian elimination on <b>A</b>. We haven't yet solved for <b>x</b> given <b>b</b>, but you should already start to see there is a bit of a problem. Partial pivoting has changed the order of the rows in <b>A</b>. This means the columns remain in the same order so the inputs remain the same (so <b>x</b> stays the same) however the new rows mean the outputs have been rearranged (the elements of <b>b</b>) and we've made no mechanism for keeping track of these changes.
</p>

<p>
<i>Page 150</i> shows us how to extract the partial pivots out of the series of pivot-eliminations we just described so that instead of: <b>G<sub>1</sub>F<sub>1</sub>G<sub>2</sub>F<sub>2</sub>..G<sub>r</sub>F<sub>r</sub></b> We have something that looks more like  <b>G<sub>1</sub>G<sub>2</sub>..G<sub>r</sub>F<sub>1</sub>F<sub>2</sub>..F<sub>r</sub></b>. The reason we've had the operations interleaved is because we do not know which rows we need to swap till the previous eliminations have been done. However if we already knew which rows to swap, then that could be done ahead of time - it would just mean the elimination steps would be a little different. What <i>page 150</i> demonstrates is that the partial-pivot adjustment can be done first as long as all eliminations for the previous pivot-columns have their values swapped to match - ie. if you adjust some pivot <i>k</i> then any previous eliminations that involved the row <i>k</i> now needs to be fixed.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-adjust-elementary-lower-triangular</span> (elementary-lower-triangular-matrix row1 row2)
  <span style="color: #cc0000;">"Take an elementary lower triangular matrix and adjust it to match a row interchange between ROW1 and ROW2 (ZERO indexed)"</span>
  (<span style="color: #00af00;">let</span> ((adjusting-matrix
         (matrix-elementary-interchange
          row1
          row2
          (matrix-rows elementary-lower-triangular-matrix))))
    (matrix-product
     adjusting-matrix
     (matrix-product
      elementary-lower-triangular-matrix
      adjusting-matrix))))
</pre>
</div>
<blockquote>
<p>
<b>Note:</b> This operation does 2 full matrix products to do a simple swap of 2 numbers, however this is also the simplest solution that doesn't involved tracking the elimination columns and fiddling with the data-list
</p>
</blockquote>

<p>
This time around we won't be simply applying our eliminations and pivots as we go, but instead we will be saving them into a list. We will have a one matrix in which we accumulate our pivot adjustments, ie. multiplying up the <b>Type I</b> matrices, and another will be a list of our elimination matrices which we will update as we go along adjusting pivots
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-to-gaussian-elimination-with-partial-pivoting</span> (elementary-lower-triangular-matrix row1 row2)
  <span style="color: #cc0000;">""</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-adjust-elimination-matrices</span> (matrix-list row1 row2)
    (<span style="color: #00af00;">cond</span> 
     ((null matrix-list)
      '())
      (t
       (cons
        (matrix-adjust-elementary-lower-triangular
         (car matrix-list)
         row1
         row2)
        (matrix-adjust-elimination-matrices
         (cdr matrix-list)
         row1
         row2)))))


  )
</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">TODOs</h2>
<div class="outline-text-2" id="text-7">
<p>
Write a better example that I can expand on easily later
Write an algo for <i>Gauss-Jordan elimination</i>
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">End</h2>
<div class="outline-text-2" id="text-8">
<blockquote>
<p>
This webpage is generated from an org-document (at <code>./index.org</code>) that also generates all the files described. 
</p>

<p>
Once opened in Emacs:<br  />
</p>
<ul class="org-ul">
<li><code>C-c C-e h h</code> generates the webpage  <br  />
</li>
<li><code>C-c C-v C-t</code> exports the code blocks into the appropriate files<br  />
</li>
</ul>
</blockquote>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: George Kontsevich</p>
<p class="date">Created: 2017-12-26 Tue 21:26</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
