<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Linear Systems in Lisp</title>
<!-- 2018-01-19 Fri 16:31 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="George Kontsevich" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://geokon-gh.github.io/static/worg.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Linear Systems in Lisp</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Preface</a></li>
<li><a href="#sec-2">Systems of linear equations</a>
<ul>
<li><a href="#sec-2-1">A farming problem</a></li>
</ul>
</li>
<li><a href="#sec-3">Matices as representations of linear systems</a>
<ul>
<li><a href="#sec-3-1">The Matrix in the computer</a>
<ul>
<li><a href="#sec-3-1-1">Some helpers</a></li>
</ul>
</li>
<li><a href="#sec-3-2">Transposition: Getting the other equivalent matrix</a></li>
</ul>
</li>
<li><a href="#sec-4">Representing the whole system of equations</a>
<ul>
<li><a href="#sec-4-1">Matrix Multiplication</a>
<ul>
<li><a href="#sec-4-1-1">Inner Product</a></li>
<li><a href="#sec-4-1-2">Submatrices</a></li>
<li><a href="#sec-4-1-3">Matrix Product</a></li>
<li><a href="#sec-4-1-4">Matrix Conformability</a></li>
<li><a href="#sec-4-1-5">Addendum: Scalar Product</a></li>
</ul>
</li>
<li><a href="#sec-4-2">A system of equations as matrix product</a>
<ul>
<li><a href="#sec-4-2-1">The mirror universe</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Chaining problems through matrix composition</a>
<ul>
<li><a href="#sec-4-3-1">Taxing our farmers</a></li>
<li><a href="#sec-4-3-2">EXAMPLE: Geometrical transformations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">Equivalent matrices</a>
<ul>
<li><a href="#sec-5-1">Identity Matrix</a></li>
<li><a href="#sec-5-2">Unit Column/Rows</a></li>
<li><a href="#sec-5-3">Addition</a></li>
<li><a href="#sec-5-4">Elementary Matrices</a>
<ul>
<li><a href="#sec-5-4-1">Type I - Row/Column Interchange</a></li>
<li><a href="#sec-5-4-2">Type II - Row/Column Multiple</a></li>
<li><a href="#sec-5-4-3">Type III - Row/Column Addition</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">The LU Decomposition</a>
<ul>
<li><a href="#sec-6-1">Gaussian elimination in matrix form</a>
<ul>
<li><a href="#sec-6-1-1">Elementary Lower Triangular Matrics</a></li>
<li><a href="#sec-6-1-2">Building the <b>L</b> Matrix</a></li>
<li><a href="#sec-6-1-3">Partial Pivoting</a></li>
<li><a href="#sec-6-1-4">Extracting the pivots</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">Using the LU</a>
<ul>
<li><a href="#sec-7-1">Solving for x in Ax=b</a></li>
<li><a href="#sec-7-2">The LDU Decomposition</a></li>
<li><a href="#sec-7-3">The Cholesky Decomposition</a></li>
<li><a href="#sec-7-4">Solving for A<sup>-1</sup></a></li>
</ul>
</li>
<li><a href="#sec-8">TODOs</a></li>
<li><a href="#sec-9">SRC<sub>Block</sub> template</a></li>
<li><a href="#sec-10">End</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Preface</h2>
<div class="outline-text-2" id="text-1">
<p>
This text is primarily my personal notes on linear algebra as I go through <i>Matrix Analysis &amp; Applied Linear Algebra</i>. At the same time this document is a literate program that can be executed in Emacs so the text will be slowly building up a linear algebra library of sorts. This will often not match the order things are presented in the book. There is no emphasis on performance - just on clarity, extensability and correctness when possible. This is purely (self)educational with my primary motivation being to help me better understand what I learn (through having to explain it) and to sanity check with actual programs. Things that are adequately explained in the book will not be repeated here.
</p>

<p>
This is my first program in Elisp, so if you see any issues, please leave a note in the <a href="https://github.com/geokon-gh/linearsystems/issues">issues</a> tab of <a href="https://github.com/geokon-gh/linearsystems/">the repository</a>. There you can also find the original org-mode file and the generated elisp files - both of which have additional unit-tests ommited from this webpage.
</p>

<p>
This is very much a work in progress and will change often&#x2026;
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Systems of linear equations</h2>
<div class="outline-text-2" id="text-2">
<p>
The book's opening problem from ancient China of calculating the price of bushels of crop serves as a good example of a linear problem. I've simplified the problem a bit for clarity - but I will expand on it and refer back to it extensively:
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">A farming problem</h3>
<div class="outline-text-3" id="text-2-1">
<blockquote>
<p>
You have a 3 fruit farms in a region of ancient China. In a given year:
</p>

<p>
<b>Given 1:</b><br  />
Farm 1 produces 3 tons of apples 2 ton of  oranges and 1 ton  of lemons<br  />
Farm 2 produces 2 tons of apples 3 tons of oranges and 1 ton  of lemons<br  />
Farm 3 produces 1 ton  of apples 2 tons of oranges and 3 tons of lemons<br  />
</p>

<p>
<b>Given 2:</b><br  />
Farm 1 sold its fruit for 39 yuan<br  />
Farm 2 sold its fruit for 34 yuan<br  />
Farm 3 sold its fruit for 26 yuan<br  />
</p>

<p>
What is the price of the a ton of apples/oranges/lemons?
</p>
</blockquote>
<p>
This is a familiar problem that can be restated as a system of linear equations
</p>

\begin{equation}
\begin{split}
3x+2y+z = 39\\
2x+3y+z = 34\\
x+ 2y + 3z = 26
\end{split}
\end{equation}

<p>
Where <code>x</code>, <code>y</code> and <code>z</code> represent <code>apples</code> <code>oranges</code> and <code>lemons</code> respectively
</p>

<p>
We know how to solve this system by manipulating the equations, solving for a variable and then back-substituting the results.
</p>

<p>
It's not accident I split up the problem into two sets of <b>Givens</b>. It's important to note that the problem actually has two distinct and independent parts. There is the farm/crop <b>linear system</b> (<code>Given 1</code>), and then there is the <b>constraint</b> of the profits of each farm (<code>Given 2</code>)
</p>

<p>
We are looking for the input fruit-prices that will yield the given profits for each farm
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Matices as representations of linear systems</h2>
<div class="outline-text-2" id="text-3">
<p>
The <b>linear system</b> can be represented with a matrix
</p>

\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 1\\
1 & 2 & 3\\
\end{bmatrix}

<p>
or flipped::
</p>

\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 2\\
1 & 1 & 3\\
\end{bmatrix}

<p>
We prefer the first representation, but both ways work as long as you remember what each row and column represents
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">The Matrix in the computer</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Once we've chosen a layout the easiest way to store the matrix in the computer is to remember 3 values: <code>number-of-rows</code> <code>number-of-columns</code> <code>data</code>
</p>

<p>
The <code>data</code> value will be a long list of size <code>num-row * num-col</code> that contains all the values of the matrix; row after row. So given a list <code>data</code> and a pair of sizes we simply build the matrix into a list of these three values: 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-from-data-list</span> (number-of-rows number-of-columns data-list)
  <span style="color: #cc0000;">"Builds a matrix from a data list"</span>
  (list 
   number-of-rows 
   number-of-columns 
   data-list))
</pre>
</div>
</div>
<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1">Some helpers</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
With a couple of helper function we can get back these 3 fields. This will improve the readability of the code as we go along
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-rows</span> (matrix)
  <span style="color: #cc0000;">"Get the number of rows"</span>
  (nth 0 matrix))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-columns</span> (matrix)
  <span style="color: #cc0000;">"Get the number of columns"</span>
  (nth 1 matrix))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-data</span> (matrix)
  <span style="color: #cc0000;">"Get the data list from the matrix"</span>
  (nth 2 matrix))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-get-value</span> (matrix row column)
  <span style="color: #cc0000;">"Get the scalar value at position ROW COLUMN (ZERO indexed) from MATRIX"</span>
  (nth
   (+
    column
    (*
     row
     (matrix-columns matrix)))
    (matrix-data matrix)))
</pre>
</div>
<blockquote>
<p>
<code>nth</code> gets the nth element of the list
</p>
</blockquote>
<p>
For debugging and looking at results we also need to be able to print out the matrix for inspection
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-data-get-first-n-values</span> (data n)
  <span style="color: #cc0000;">"Given a list of values, get the first n in a string"</span>
  (<span style="color: #00af00;">if</span> (zerop n)
      <span style="color: #ff1f8b;">""</span> <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">base case</span>
    (concat
     (number-to-string (car data))
     <span style="color: #ff1f8b;">" "</span>
     (matrix-data-get-first-n-values (cdr data) (1- n))))) <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">iterative step</span>

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-data-print</span> (number-of-rows number-of-columns data)
  <span style="color: #cc0000;">"Print out the data list gives the dimension of the original matrix"</span>
  (<span style="color: #00af00;">if</span> (zerop number-of-rows)
      <span style="color: #ff1f8b;">""</span> <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">base case</span>
    (concat
     (matrix-data-get-first-n-values data number-of-columns)
     <span style="color: #ff1f8b;">"\n"</span>
     (matrix-data-print <span style="color: #b2b2b2; font-style: italic;">;</span><span style="color: #b2b2b2; font-style: italic;">iterative step</span>
      (1- number-of-rows)
      number-of-columns
      (nthcdr number-of-columns data )))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-print</span> (matrix)
  <span style="color: #cc0000;">"Print out the matrix"</span>
  (concat <span style="color: #ff1f8b;">"\n"</span> (matrix-data-print
                (matrix-rows matrix)
                (matrix-columns matrix)
                (matrix-data matrix))))
<span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">ex:  (message (matrix-print (matrix-from-data-list 2 2 '(1 2 3 4))))</span>
</pre>
</div>
<blockquote>
<p>
<code>zerop</code> tests if the value is zero
</p>
</blockquote>
<blockquote>
<p>
<code>()</code> with a quote is the <i>empty-list</i> 
</p>
</blockquote>
<blockquote>
<p>
<code>cons</code> attaches the first argument to the second argument (which is normally a list)
</p>
</blockquote>
<blockquote>
<p>
<code>cdr</code> returns the list without the first element
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Transposition: Getting the other equivalent matrix</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Since we have two equivalent matrices that represent our linear system we need a mechanism to go from one to the other. This method is the matrix transpose which flips the matrix along the diagonal. The text goes into depth on the properties of the matrix transpose, but in short, as long as you take the transpose of both sides of your equations equivalances will be preserved.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-transpose</span> (matrix)
  <span style="color: #cc0000;">"Get the transpose of a matrix"</span>
  (<span style="color: #00af00;">if</span> (equal (matrix-columns matrix) 1)
    (matrix-from-data-list
     1
     (matrix-rows matrix)
     (matrix-data matrix))
    (matrix-append
     (matrix-from-data-list
      1
      (matrix-rows matrix)
      (matrix-data (matrix-get-column matrix 0)))
     (matrix-transpose
      (matrix-submatrix
       matrix
       0
       1
       (matrix-rows matrix)
       (matrix-columns matrix))))))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Representing the whole system of equations</h2>
<div class="outline-text-2" id="text-4">
<p>
Now that we can represent the fruit/profits system we want a mechanism to represent the whole system of equations so that given a constraint, we can solve for a solution.
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Matrix Multiplication</h3>
<div class="outline-text-3" id="text-4-1">
<p>
This is done notationally with matrix multiplication. The notation allows us to keep the two <b>Givens</b> separated and allows us to visually chain linear systems together. As a shorthand, we write the product of two matrices <code>A</code> and <code>B</code> as <code>AB = C</code>, with the order of <code>A</code> and <code>B</code> being important. For every value (at a given row and column position) in the resulting matrix <code>C</code> we take the equivalent row in <code>A</code> and multiply it by its equivalent column in <code>B</code>. From this we can conclude that <code>C</code> will have as many rows as <code>A</code> and as many column as <code>B</code>
</p>

<p>
Multiplying a row times a column is called an <code>inner product</code>
</p>
</div>

<div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1">Inner Product</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
The <code>inner-product</code> is defined as the sum of the product of every pair of equivalent elements in the two vectors. The sum will naturally return one scalar value. This operation only makes sense if both the row and column have the same number of values.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-inner-product-data</span> (row-data column-data)
  <span style="color: #cc0000;">"Multiply a row times a column and returns a scalar. If they're empty you will get zero"</span>
  (reduce
   '+
   (for-each-pair
    row-data
    column-data
   '*)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-inner-product</span> (row column)
  <span style="color: #cc0000;">"Multiply a row times a column and returns a scalar. If they're empty you will get zero"</span>
  (matrix-inner-product-data 
   (matrix-data row)
   (matrix-data column)))
</pre>
</div>
<blockquote>
<p>
<code>reduce</code> works down the list elements-by-element applying the operator on each cumulative result
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2">Submatrices</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
To get rows and columns (and other submatrices) we need a few more helper functions
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-extract-subrow</span> (matrix row start-column end-column)
  <span style="color: #cc0000;">"Get part of a row of a matrix and generate a row matrix from it. START-COLUMN is inclusive,  END-COLUMN is exclusive"</span>
  (<span style="color: #00af00;">let</span>
      ((number-of-columns-on-input (matrix-columns matrix))
       (number-of-columns-on-output (-
                                     end-column 
                                     start-column)))
    (matrix-from-data-list
     1
     number-of-columns-on-output
     (subseq
      (matrix-data matrix)
      (+ (* row number-of-columns-on-input) start-column)
      (+ (* row number-of-columns-on-input) end-column)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-append</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Append one matrix (set of linear equations) to another"</span>
  (<span style="color: #00af00;">if</span> (null matrix2)
      matrix1
    (matrix-from-data-list
     (+
      (matrix-rows matrix2)
      (matrix-rows matrix1))
     (matrix-columns matrix1)
     (append
      (matrix-data matrix1)
      (matrix-data matrix2)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-submatrix</span> (matrix start-row start-column end-row end-column)
  <span style="color: #cc0000;">"Get a submatrix. start-row/column are inclusive. end-row/column are exclusive"</span>
  (<span style="color: #00af00;">if</span> (equal start-row end-row)
      '()
    (matrix-append
     (matrix-extract-subrow matrix start-row start-column end-column)
     (matrix-submatrix
      matrix
      (1+ start-row)
      start-column
      end-row
      end-column))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-get-row</span> (matrix row)
  <span style="color: #cc0000;">"Get a row from a matrix. Index starts are ZERO"</span>
  (matrix-extract-subrow
   matrix
   row
   0
   (matrix-columns matrix)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-get-column</span> (matrix column)
  <span style="color: #cc0000;">"Get a column from a matrix. Index starts are ZERO"</span>
  (matrix-submatrix
   matrix
   0
   column
   (nth 0 matrix)
   (1+ column)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3">Matrix Product</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Now we have all the tools we need to write down the algorithm for calculating the matrix product. First we write a function to calculate the product for one value at a given position
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-product-one-value</span> (matrix1 matrix2 row column)
  <span style="color: #cc0000;">"Calculate one value in the resulting matrix of the product of two matrices"</span>
  (matrix-inner-product
   (matrix-get-row matrix1 row )
   (matrix-get-column matrix2 column)))
</pre>
</div>
<p>
And then we recursively apply it to construct the resulting matrix
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-product</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Multiply two matrices"</span>

  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-product-rec</span> (matrix1 matrix2 row column)
    <span style="color: #cc0000;">"A recursive helper function that builds the matrix multiplication's data vector"</span>
    (<span style="color: #00af00;">if</span> (equal (matrix-rows matrix1) row)
        '()
      (<span style="color: #00af00;">if</span> (equal (matrix-columns matrix2) column)
          (matrix-product-rec
           matrix1
           matrix2
           (1+ row)
           0)
        (cons
         (matrix-product-one-value
          matrix1
          matrix2
          row column)
         (matrix-product-rec
          matrix1
          matrix2
          row
          (1+ column))))))

  (matrix-from-data-list
   (matrix-rows matrix1)
   (matrix-columns matrix2)
   (matrix-product-rec
    matrix1
    matrix2
    0
    0)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-1-4" class="outline-4">
<h4 id="sec-4-1-4">Matrix Conformability</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
You will notice that the algorithm won't make sense if the number of columns of <code>A</code> doesn't match the number of rows of <code>B</code>. When the values match the matrices are called <b>conformable</b>. When they <i>don't</i> match you will see that inner product isn't defined and therefore neither is the product.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-conformable?</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Check that two matrices can be multiplied"</span>
  (equal
   (matrix-columns matrix1)
   (matrix-rows matrix2)))
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-1-5" class="outline-4">
<h4 id="sec-4-1-5">Addendum: Scalar Product</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
An additional form of matrix multiplication is between a matrix and a scalar. Here we simply multiply each element of the matrix times the scalar to construct the resulting matrix. The order of multiplication is not important -&gt; <b>&alpha;A=A&alpha;</b>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-scalar-product</span> (matrix scalar)
  <span style="color: #cc0000;">"Multiple the matrix by a scalar. ie. multiply each value by the scalar"</span>
  (matrix-from-data-list
   (matrix-rows matrix)
   (matrix-columns matrix)
   (mapcar
   (<span style="color: #00af00;">lambda</span> (x) 
     (* scalar x))
   (matrix-data matrix))))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">A system of equations as matrix product</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Now that we have all our tools we can write down a matrix product that will mimic our system of equation.
</p>

\begin{equation}
\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 1\\
1 & 2 & 3\\
\end{bmatrix}
\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}
=
\begin{bmatrix}
39\\
34\\
26\\
\end{bmatrix}
\end{equation}

<p>
Going through our algorithm manually we see that the resulting matrix is:
</p>

\begin{equation}
\begin{bmatrix}
3x + 2y + z\\
2x + 3y + z\\
x + 2y + 3z\\
\end{bmatrix}
=
\begin{bmatrix}
39\\
34\\
26\\
\end{bmatrix}
\end{equation}
</div>

<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">The mirror universe</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Now I said that flipped matrix was also a valid representation. We can confirm this by taking the transpose of both sides 
</p>


\begin{equation}
\begin{bmatrix}
x & y & z\\
\end{bmatrix}
\begin{bmatrix}
3 & 2 & 1\\
2 & 3 & 2\\
1 & 1 & 3\\
\end{bmatrix}
=
\begin{bmatrix}
39 & 34 & 26\\
\end{bmatrix}
\end{equation}


<p>
It yields another matrix product that mimics the equations, however you'll see in the textbook that we always prefer the first notation.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Chaining problems through matrix composition</h3>
<div class="outline-text-3" id="text-4-3">
<p>
The real power of matrix multiplication is in its ability to chain systems together through <b>linear composition</b>
</p>

<p>
If we are given a new problem that take the output of our first system and produces a new output - composition gives us a mechanism to combine the systems into one.
</p>
</div>

<div id="outline-container-sec-4-3-1" class="outline-4">
<h4 id="sec-4-3-1">Taxing our farmers</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
Say the imperial palace has a system for collecting taxes
</p>
<blockquote>
<p>
<b>Given</b>:<br  />
The farms have to pay a percentage of their income to different regional governements. The breakdown is as follows:<br  />
The town taxes Farm 1 at 5%, Farm 2 at 3%, Farm 3 at 7%<br  />
The province taxes all Farm 1 at 2% Farm 2 at 4%, Farm 3 at 2%<br  />
The palace taxes all farms at 7%
</p>
</blockquote>
<p>
Now, given the income of each farm <b>i</b> we can build a new matrix <b>B</b> and calculate the tax revenue of each government - <b>t</b>.<br  />
</p>

\begin{equation}
Bi=t
\end{equation}

<p>
From the previous problem we know that the income of each farm was already a system of equation with the price of fruit as input <b>f</b><br  />
</p>

\begin{equation}
Af=i
\end{equation}

<p>
So we just plug one into the other and get<br  />
</p>
\begin{equation}
B(Af)=t
\end{equation}

<p>
and compose a new equation that given the price of fruit gives us the regional tax revenue. By carrying out the product we can generate one linear system<br  />
</p>

\begin{equation}
(BA)f=t\\
\end{equation} 
<p>
Where if <b>BA=C</b> the final composed system is:
</p>
\begin{equation}
Cf=t
\end{equation} 
<p>
Note that the rows of <b>BA</b> are the combination of the rows of <b>A</b> and the columns of <b>BA</b> are the combination of the columns of <b>B</b> - at the same time! (see page 98)
</p>
</div>
</div>
<div id="outline-container-sec-4-3-2" class="outline-4">
<h4 id="sec-4-3-2">EXAMPLE: Geometrical transformations</h4>
<div class="outline-text-4" id="text-4-3-2">
<p>
A very simple example are the linear systems that takes coordinates <i>x y</i> and do transformations on them
</p>

<p>
<b>Rotation</b>
</p>
\begin{equation}
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
=
\begin{bmatrix}
x_{rotated}\\
y_{rotated}\\
\end{bmatrix}
\end{equation}

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-rotate-2D</span> (radians)
  <span style="color: #cc0000;">"Generate a matrix that will rotates a [x y] column vector by RADIANS"</span>
  (matrix-from-data-list
   2
   2
   (list
     (cos radians)
     (- (sin radians))
     (sin radians)
     (cos radians))))
</pre>
</div>
<p>
<b>Reflection about X-Axis</b>
</p>
\begin{equation}
\begin{bmatrix}
1 & 0 \\
0 & -1\\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
=
\begin{bmatrix}
x_{reflected}\\
y_{reflected}\\
\end{bmatrix}
\end{equation}

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-reflect-around-x-2D</span> ()
  <span style="color: #cc0000;">"Generate a matrix that will reflect a [x y] column vector around the x axis"</span>
  (matrix-from-data-list
   2
   2
   '(1 0 0 -1)))
</pre>
</div>
<p>
<b>Projection on line</b>
</p>
\begin{equation}
\begin{bmatrix}
1/2 & 1/2 \\
1/2 & 1/2\\
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
\end{bmatrix}
=
\begin{bmatrix}
x_{projected}\\
y_{projected}\\
\end{bmatrix}
\end{equation}

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-project-on-x=y-diagonal-2D</span> ()
  <span style="color: #cc0000;">"Generate a matrix that projects a point ([x y] column vector) onto a line (defined w/ a unit-vector)"</span>
  (matrix-from-data-list
   2
   2
   '(0.5 0.5 0.5 0.5)))
</pre>
</div>
<p>
So given a point <i>[x y]</i> (represented by the column vector <b>v</b>) we can use these 3 transformation matrices to move it around our 2D space. We simple write a chain of transformations <b>T</b> and multiply them times the given vector <b>T<sub>1</sub>T<sub>2</sub>T<sub>3</sub>v=v<sub>new</sub></b>. These transformation matrices can then be multiplied together into one that will carry out the transformation in one matrix product. <b>T<sub>1</sub>T<sub>2</sub>T<sub>3</sub>=T<sub>total</sub></b> =&gt; <b>T<sub>total</sub>v=v<sub>new</sub></b> 
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Equivalent matrices</h2>
<div class="outline-text-2" id="text-5">
<p>
Now thanks to matrix multiplication we can represent linear systems and we can chain them together. The next step is extending multiplication to represent general manipulations of matrices.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Identity Matrix</h3>
<div class="outline-text-3" id="text-5-1">
<p>
For any matrix <b>A</b>, the identity matrix <b>I</b> is such that <b>A*I</b> = <b>A</b> = <b>I*A</b>. Given the dimensions, <b>I</b> has to be a square matrix. It will have <b>1</b>'s on the diagonal (ie. where <code>row==column</code>) and zeroes everywhere else. We build it recursively:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-identity</span> (rank)
  <span style="color: #cc0000;">"Build an identity matrix of the given size/rank"</span>

  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-build-identity-rec</span> (rank row column)
    <span style="color: #cc0000;">"Helper function that build the data vector of the identity matrix"</span>
    (<span style="color: #00af00;">if</span> (equal column rank) <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">time to build next row</span>
        (<span style="color: #00af00;">if</span> (equal row (1- rank))
            '() <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">we're done</span>
          (matrix-build-identity-rec
           rank
           (1+ row)
           0))
      (<span style="color: #00af00;">if</span> (equal row column)
          (cons
           1.0
           (matrix-build-identity-rec
            rank
            row
            (1+ column)))
        (cons
         0.0
         (matrix-build-identity-rec
          rank
          row
          (1+ column))))))

  (matrix-from-data-list rank rank (matrix-build-identity-rec rank 0 0 )))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Unit Column/Rows</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Each column of the <b>identity matrix</b> is a unit column (denoted as <b>e<sub><i>j</i></sub></b>). It contains a <b>1</b> in a given postion (here: <i>j</i>) and <b>0s</b> everwhere else. Its transpose is naturally called the <b>unit row</b><br  />
<b>Ae<sub><i>j</i></sub></b> = the <i>j</i> column of A<br  />
<b>e<sub><i>i</i></sub><sup>T</sup>A</b> = the <i>i</i> row of A<br  />
<b>e<sub><i>i</i></sub><sup>T</sup>Ae<sub><i>j</i></sub></b> = gets the [ <i>i</i>, <i>j</i> ] element in A
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-unit-rowcol-data</span> (index size)
<span style="color: #cc0000;">"Create a data-list for a matrix row/column. INDEX (starts at ZERO) matches the row or column where you want a 1. SIZE is the overall size of the vector"</span>
(<span style="color: #00af00;">if</span> (zerop size)
    '()
  (<span style="color: #00af00;">if</span> (zerop index)
      (cons
       1.0
       (matrix-unit-rowcol-data
        (1- index)
        (1- size)))
    (cons
     0.0
     (matrix-unit-rowcol-data
      (1- index)
      (1- size))))))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-unit-column</span> (row size)
  <span style="color: #cc0000;">"Build a unit column. ROW is where you want the 1 to be placed (ZERO indexed). SIZE is the overall length"</span>
      (matrix-from-data-list
       size
       1
       (matrix-unit-rowcol-data
        row
        size)))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-unit-row</span> (column size)
  <span style="color: #cc0000;">"Build a unit column. COLUMN is where you want the 1 to be placed (ZERO indexed). SIZE is the overall length"</span>
      (matrix-from-data-list
       1
       size
       (matrix-unit-rowcol-data
        column
        size)))
</pre>
</div>
<blockquote>
<p>
Here I'm just trying out a new notation. With <code>letrec</code> we can hide the recursive helper function inside the function that uses it.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">Addition</h3>
<div class="outline-text-3" id="text-5-3">
<p>
As a tool in building new matrices, we need a way to easily add two matrices, ie. add their values one to one. Matrices that are added need to have the same size.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-equal-size-p</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Check if 2 matrices are the same size"</span>
  (<span style="color: #00af00;">and</span>
   (equal
    (matrix-rows matrix1)
    (matrix-rows matrix2))
   (equal
    (matrix-columns matrix1)
    (matrix-columns matrix2))))
(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">for-each-pair</span> (list1 list2 operator)
  <span style="color: #cc0000;">"Go through 2 lists applying an operator on each pair of elements"</span>
  (<span style="color: #00af00;">if</span> (null list1)
      '()
    (cons
     (funcall operator (car list1) (car list2))
     (for-each-pair (cdr list1) (cdr list2) operator))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-add</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Add to matrices together"</span>
  (<span style="color: #00af00;">if</span> (matrix-equal-size-p matrix1 matrix2)
      (matrix-from-data-list
       (matrix-rows matrix1)
       (matrix-columns matrix1)
       (for-each-pair
        (matrix-data matrix1)
        (matrix-data matrix2)
        '+))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-subtract</span> (matrix1 matrix2)
  <span style="color: #cc0000;">"Subtract MATRIX2 from MATRIX1"</span>
  (<span style="color: #00af00;">if</span> (matrix-equal-size-p matrix1 matrix2)
      (matrix-from-data-list
       (matrix-rows matrix1)
       (matrix-columns matrix1)
       (for-each-pair
        (matrix-data matrix1)
        (matrix-data matrix2)
        '-))))
</pre>
</div>
<blockquote>
<p>
<code>funcall</code> applied the first arugment (a function) with the remaining items in the list as arguments
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Elementary Matrices</h3>
<div class="outline-text-3" id="text-5-4">
<p>
The manipulation of the rows and columns can be broken down into 3 types of <b>elementary matrices</b> that when multiplied with our <b>linear systems</b> will generate <b>equivalent</b> matrices (<b>E</b>). 
</p>

<p>
<i>(from page 134)</i>
When applied from the <i>left</i> <b>EA=B</b> it performs a row operation and makes a <b>row equivalent</b> matrix.<br  />
When applied from the <i>right</i> <b>AE=B</b> it performs a column operation and makes a <b>column equivalent</b> matrix.<br  />
</p>

<p>
Row/column operations are ofcourse reversible and therefore <b>E</b> is invertible and a <b>E<sup>-1</sup></b> always exists.
</p>

<p>
So now, waving our hands a little, given a non-singular matrix we can restate <i>Gauss-Jordan elimination</i> as "a bunch of row operations that turn our matrix into the identity matrix". Ie: <b>E<sub>k</sub>..E<sub>2</sub>E<sub>1</sub>A=I</b><br  />
And thanks to each operations' invertibility we can flip it to be <b>A=E<sub>1</sub><sup>-1</sup>E<sub>2</sub><sup>-1</sup>..E<sub>k</sub><sup>-1</sup></b><br  />
So Gauss-Jordan elimination for non-singular matrices has given us our first decomposition of sorts! We now know that every non-singular matrix can be written as a chain of row (or column) operations.
</p>

<p>
Row/Column operations come in 3 flavors
</p>
</div>
<div id="outline-container-sec-5-4-1" class="outline-4">
<h4 id="sec-5-4-1">Type I - Row/Column Interchange</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
Interchaning rows (or columns) <i>i</i> and <i>j</i>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-interchange</span> (rowcol1 rowcol2 rank)
  <span style="color: #cc0000;">"Make an elementary row/column interchange matrix for ROWCOL1 and ROWCOL2 (ZERO indexed)"</span>
  (<span style="color: #00af00;">let</span> ((u
         (matrix-subtract
          (matrix-unit-column rowcol1 rank)
          (matrix-unit-column rowcol2 rank))))
  (matrix-subtract
   (matrix-identity rank)
   (matrix-product
    u
    (matrix-transpose u)))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-interchange-inverse</span> (rowcol1 rowcol2 rank)
  <span style="color: #cc0000;">"Make the inverse of the elementary row/column interchange matrix for ROWCOL1 and ROWCOL2 (ZERO indexed). This is identical to (matrix-elementary-interchange)"</span>
  (matrix-elementary-interchange
   rowcol1
   rowcol2
   rank))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-2" class="outline-4">
<h4 id="sec-5-4-2">Type II - Row/Column Multiple</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
Multiplying row (or column) <i>i</i> by <i>&alpha;</i>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-multiply</span> (rowcol scalar rank)
  <span style="color: #cc0000;">"Make an elementary row/column multiple matrix for a given ROWCOL (ZERO indexed)"</span>
  (<span style="color: #00af00;">let</span> ((elementary-column
         (matrix-unit-column rowcol rank)))
  (matrix-subtract
   (matrix-identity rank)
   (matrix-product
    elementary-column
    (matrix-scalar-product
     (matrix-transpose elementary-column)
     (- 1 scalar))))))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-multiply-inverse</span> (rowcol scalar rank)
  <span style="color: #cc0000;">"Make the inverseof the elementary row/column multiple matrix for a given ROWCOL (ZERO indexed)"</span>
  (matrix-elementary-multiply
   rowcol
   (/ 1 scalar)
   rank))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4-3" class="outline-4">
<h4 id="sec-5-4-3">Type III - Row/Column Addition</h4>
<div class="outline-text-4" id="text-5-4-3">
<p>
Adding a multiple of a row (or column) <i>i</i> to row (or column) <i>j</i>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-addition</span> (rowcol1 rowcol2 scalar rank)
  <span style="color: #cc0000;">"Make an elementary row/column product addition matrix. Multiply ROWCOL1 (ZERO indexed) by SCALAR and add it to ROWCOL2 (ZERO indexed)"</span>
  (matrix-add
   (matrix-identity rank)
   (matrix-scalar-product
    (matrix-product
     (matrix-unit-column rowcol2 rank)
     (matrix-transpose
      (matrix-unit-column rowcol1 rank)))
    scalar)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-addition-inverse</span> (rowcol1 rowcol2 scalar rank)
  <span style="color: #cc0000;">"Make the inverse of the elementary row/column product addition matrix. Multiply ROWCOL1 (ZERO indexed) by SCALAR and add it to ROWCOL2 (ZERO indexed)"</span>
  (matrix-elementary-addition
   rowcol1
   rowcol2
   (- scalar)
   rank))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">The LU Decomposition</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">Gaussian elimination in matrix form</h3>
<div class="outline-text-3" id="text-6-1">
<p>
If linear equations at their simplest take inputs and produce some outputs, then Gaussian elimination is our method of reversing the process. It's a systematic way for taking a known linear system with a given output and solving for its input. Because we know that adding and scaling equations preserves equalities, Gaussian elimination is a scheme for combining and swapping equations so that they reduce to something simpler which can be solved directly. We do this by elimination factors in our equations such that the last one is of the form <b>&alpha;x=b</b>. Equalities being preserved, we can use this simple equation to solve for one of the unknown inputs. Each of the remaining equation includes just one additional unknow input so that through back-substitution we can then solve for all of them one by one. 
</p>

<p>
So if <b>Ax=b</b> is our original system of equations in matrix form, then after Gaussian elimination we can write our simplified systm as <b>Ux=b<sub>new</sub></b>. Combining our equations has changed our output values, so the <b>b</b> has changes as well.
</p>

<p>
<i>From the Example on page 141</i> <br  />
So if we started with an <b>A</b> that looked like this
</p>
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
<p>
Gaussian elimination will give us a <b>U</b> that look like this:
</p>
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 0 & 4\\
\end{bmatrix}
<p>
Looking at the system of equations <b>Ux=b<sub>new</sub></b> and  given a <b>b<sub>new</sub></b> we can see that the last row in <b>U</b> - [ 0 0 4 ] times the column [ x<sub>1</sub> x<sub>2</sub> x<sub>3</sub> ]<sup>T</sup> gives us a direct solution for x<sub>3</sub>. Then using <b>x<sub>3</sub></b> and the previous row/equation we could solve for <b>x<sub>2</sub></b> and so on.
</p>

<p>
Combining and swapping rows is something we just learned how to do using elementary matrices- so by cleverly taking their product with our matrix <b>A</b> we will be able to generate the <b>U</b> matrix - in effect reenacting Gaussian elimination using matrix multiplication. If each row manipulation is some elementary matrix <b>R<sub>n</sub></b> we could write out the process of Gaussian elimination as a series of products <b>R<sub>n</sub>R<sub>&#x2026;</sub>R<sub>2</sub>R<sub>1</sub>A=U</b>. Looking at <b>Ax=b</b> it's just the same - we simply multiply by both sides by the <b>R</b> matrices <b>R<sub>n</sub>R<sub>&#x2026;</sub>R<sub>2</sub>R<sub>1</sub>(Ax)=R<sub>1</sub>R<sub>2</sub>R<sub>&#x2026;</sub>R<sub>n</sub>b</b>. As we were hoping for, the left side will be <b>Ux</b> and the right hand side is our <b>b<sub>new</sub></b>.
</p>

<p>
On a high level the reduction of the equations happens in two repeated steps on each column: First we adjust the pivot and then we eliminate all the factors below it. In the matrix representation this is equivalent to adjusting the diagonal element and then making all the values below it equal to zero. The combination of the two <b>reduces the column</b> and make our system simpler. 
</p>

<blockquote>
<p>
<b>Note:</b> Gaussian elimination will only produce a solution for nonsingular square matrices, so the process described only holds for this case
</p>
</blockquote>
</div>
<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1">Elementary Lower Triangular Matrics</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
The example I used above was done without adjusting any pivots. We reducing the first column by simply eliminated the values below the <code>2</code> (in the upper left) and we could have done that by multiply our <b>A</b> by two <code>Type III</code> <b>elementary matrices</b> from the left like so:
</p>
\begin{equation}
\begin{bmatrix}
1 & 0 & 0\\
-2 & 1 & 0\\
0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
-3 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 12 & 16\\
\end{bmatrix}
\end{equation}
<p>
The two <code>Type III</code> <b>elementary matrices</b> on the left are pretty simple and you can visually see what the <code>-2</code> and <code>-3</code> represent. They match the entry in <b>A</b> at the same index (row/column), but divided by the value of the pivot (ie: the factor that will eliminate the value). The result is that the first column has been reduced and we are closer to our upper triangular <b>U</b>
</p>

<p>
Constructing these simple <code>Type III</code> matrices is quick and inverting them is as easy as flipping the sign on the factor (ie. if you subtract some multiple of an equation from another, to reverse the operation you'd simply add the same multiple of the equation back)
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-row-elimination</span> (matrix row column)
  <span style="color: #cc0000;">"Make a matrix that will eliminate an element at the specified ROW/COLUMN (ZERO indexed) using the diagonal element in the same column (typically the pivot)"</span>
  (<span style="color: #00af00;">let</span>
      ((pivot (matrix-get-value matrix column column))
       (element-to-eliminate (matrix-get-value matrix row column)))
    (matrix-elementary-addition
     column
     row
     (-
      (/
       element-to-eliminate
       pivot))
     (matrix-rows matrix))))
</pre>
</div>

<p>
Looking again at the product of 2 <code>Type III</code> matrices with our <b>A</b>, and using what we know about composing linear systems, we already know that we can take the product of the first two matrices separately. Whatever matrix comes out we can then multiply times <b>A</b> to give us the same result.
</p>
\begin{equation}
\begin{pmatrix}
\begin{bmatrix}
1 & 0 & 0\\
-2 & 1 & 0\\
0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
-3 & 0 & 1\\
\end{bmatrix}
\end{pmatrix}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 12 & 16\\
\end{bmatrix}
\end{equation}


\begin{equation}
\begin{bmatrix}
1 & 0 & 0\\
-2 & 1 & 0\\
-3 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 12 & 16\\
\end{bmatrix}
\end{equation}

<p>
The result is surprisingly simple and we can see that we didn't really need to carry out the whole matrix product b/c we've simply merged the factors into one matrix. So we can simply build these matrices that eliminate entire columns and skip making tons of <code>Type III</code> matrices entirely. The new combined matrices are called <b>Elementary Lower-Triangular Matrix</b> and are described on <i>page 142</i>.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-lower-triangular</span> (matrix column-to-clear)
  <span style="color: #cc0000;">"Make a matrix that will eliminate all rows in a column below the diagonal (pivot position)"</span>

  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-elementary-lower-triangular-rec</span> (matrix column-to-clear row-to-build rank)
    <span style="color: #cc0000;">"Recursive function to build the elementary lower triangular matrix"</span>
    (<span style="color: #00af00;">cond</span>
     ((equal
       rank
       row-to-build) <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">Done building the matrix</span>
      '())
     ((&lt;=
       row-to-build
       column-to-clear) <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">Building the simply "identity" portion above the pivot</span>
      (matrix-append
       (matrix-unit-row row-to-build rank)
       (matrix-elementary-lower-triangular-rec
        matrix
        column-to-clear
        (1+ row-to-build)
        rank)))
     (t <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">Build the elimination portion below the pivot</span>
      (<span style="color: #00af00;">let</span>
          ((pivot (matrix-get-value matrix column-to-clear column-to-clear))
           (element-to-eliminate (matrix-get-value matrix row-to-build column-to-clear)))
        (<span style="color: #00af00;">let</span>
            ((cancellation-factor (-
                                   (/
                                    element-to-eliminate
                                    pivot))))
          (matrix-append
           (matrix-add
            (matrix-unit-row row-to-build rank)
            (matrix-scalar-product
             (matrix-unit-row column-to-clear rank)
             cancellation-factor))
           (matrix-elementary-lower-triangular-rec
            matrix
            column-to-clear
            (1+ row-to-build)
            rank)))))))

  (matrix-elementary-lower-triangular-rec
   matrix
   column-to-clear
   0
   (matrix-rows matrix)))
</pre>
</div>
</div>
</div>


<div id="outline-container-sec-6-1-2" class="outline-4">
<h4 id="sec-6-1-2">Building the <b>L</b> Matrix</h4>
<div class="outline-text-4" id="text-6-1-2">
<p>
So now our product of elementary matrices <b>R<sub>n</sub>R<sub>&#x2026;</sub>R<sub>2</sub>R<sub>1</sub>A=U</b> shortens to something similar <b>G<sub>r</sub>G<sub>&#x2026;</sub>G<sub>2</sub>G<sub>1</sub>A=U</b>, but where each <i>Elementary Lower-Triangular Matrix</i> <b>G</b> takes the place of several <b>R</b> matrices. The product <b>G<sub>r</sub>G<sub>&#x2026;</sub>G<sub>2</sub>G<sub>1</sub></b> involved a lot of matrix products, but fortuntately we have a shortcut. These <b>G</b> matrices have the property that their inverse is just a matter of flipping the sign of the factors' in their column. You can confirm this by inverting our definition <b>G=R<sub>n</sub>R<sub>&#x2026;</sub>R<sub>2</sub>R<sub>1</sub></b> and remembering that the <b>R</b>'s just involve a sign flip and <b>R<sup>-1</sup></b>'s are also <code>Type III</code> matrices. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-invert-elementary-lower-triangular</span> (matrix-elementary-lower-triangular)
  <span style="color: #cc0000;">"Inverts an L matrix by changing the sign on all the factors below the diagonal"</span>
  (matrix-add
   (matrix-scalar-product
    matrix-elementary-lower-triangular
    -1)
   (matrix-scalar-product
    (matrix-identity
     (matrix-rows matrix-elementary-lower-triangular))
    2)))
</pre>
</div>
<blockquote>
<p>
<b>TODO</b>: Add a function to build the inverse directly
</p>
</blockquote>


<p>
This allows us to take our equation <b>G<sub>1</sub>G<sub>2</sub>G<sub>&#x2026;</sub>G<sub>n</sub>A=U</b> and trivially produce the interesting equality <b>A=G<sup>-1</sup><sub>1</sub>G<sup>-1</sup><sub>2</sub>G<sup>-1</sup><sub>&#x2026;</sub>G<sub>n</sub>U</b> without having to compute a single value; just flip the order of the product and flup the signs. Now the product <b>G<sup>-1</sup><sub>1</sub>G<sup>-1</sup><sub>2</sub>G<sup>-1</sup><sub>&#x2026;</sub>G<sub>n</sub></b> is special and <i>page 143</i> describes how all the factors just move into one matrix without having to do any calculation. (<b>Note</b>: that the same doesn't hold for the non-inverted product!) The combined product produces the lower triangular matrix <b>L</b> and lets us write down <b>A=LU</b> - from which we get the name of the decomposition. (see <i>page 143-144</i> <b><i>eq 3.10.6</i></b> )
</p>

<p>
To finish our example we will first add another matrix to the left to eliminate the second column in <b>A</b> so that we have the equation <b>G<sub>2</sub>G<sub>1</sub>A=U</b>
</p>

\begin{equation}
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & -4 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0\\
-2 & 1 & 0\\
-3 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 0 & 4\\
\end{bmatrix}
\end{equation}

<blockquote>
<p>
<b>Note</b> that the factor of <code>-4</code> was only deduced after doing the reduction of the first column which had given us:
</p>

\begin{bmatrix}
2 & 2 & 1\\
0 & 3 & 3\\
0 & 12 & 16\\
\end{bmatrix}

<p>
So you can't reduce the second column before you'd reduced the first!
</p>
</blockquote>

<p>
Next we invert our two 2 <b>G</b> matrices and bring them to other side to get <b>A=G<sub>1</sub><sup>-1</sup>G<sub>2</sub><sup>-1</sup>U</b> (Notice how the order of the <b>G</b>'s has changed b/c of the inversion)
</p>

\begin{equation}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 4 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0\\
2 & 1 & 0\\
3 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 0 & 4\\
\end{bmatrix}
\end{equation}

<p>
Now multiplying the two inverted matrices is quick and easy b/c we just need to merge the factors into one matrix:
</p>

\begin{equation}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{pmatrix}
\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 4 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0\\
2 & 1 & 0\\
3 & 0 & 1\\
\end{bmatrix}
\end{pmatrix}
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 0 & 4\\
\end{bmatrix}
\end{equation}


\begin{equation}
\begin{bmatrix}
2 & 2 & 2\\
4 & 7 & 7\\
6 & 18 & 22\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 0 & 0\\
2 & 1 & 0\\
3 & 4 & 1\\
\end{bmatrix}
\begin{bmatrix}
2 & 2 & 2\\
0 & 3 & 3\\
0 & 0 & 4\\
\end{bmatrix}
\end{equation}

<p>
And we are left with <b>A=LU</b>
</p>
</div>
</div>

<div id="outline-container-sec-6-1-3" class="outline-4">
<h4 id="sec-6-1-3">Partial Pivoting</h4>
<div class="outline-text-4" id="text-6-1-3">
<p>
The previous example showed us how to eliminate columns, but in general before we do elimination we need to adjust the pivot in that column. First we may find that after performing elimination on a previous column we are left with a zero in the current column's pivot position - which makes it impossible to eliminate the factors below it. Second, adjusting the pivot can improve our solution's numerical stability. The strategy we're using is called <b>partial pivoting</b> and will swap in to the pivot position whichever row has the maximal value for that column. It will ensure that our results have less error and can also be done pretty easily by taking the product of our matrix with a <code>Type I</code> elementary matrix.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-partial-pivot</span> (matrix pivot-column)
    <span style="color: #cc0000;">"Adjust the pivot in the PIVOT-COLUMN to be have the maximal magnititude in that column"</span>
    (<span style="color: #00af00;">let</span> ((column-below-pivot (matrix-submatrix
                               matrix
                               pivot-column
                               pivot-column
                               (matrix-rows matrix)
                               (1+ pivot-column))))
      (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">find-max-index</span> (data-list max-val max-index current-index)
        (<span style="color: #00af00;">cond</span>
         ((null data-list)
          max-index)
         ((&gt;
           (abs(car data-list))
           max-val)
          (find-max-index
           (cdr data-list)
           (abs(car data-list))
           current-index
           (1+ current-index)))
         (t
          (find-max-index
           (cdr data-list)
           max-val
           max-index
           (1+ current-index)))))

     (matrix-elementary-interchange
      pivot-column
      (+
       pivot-column
       (find-max-index
        (matrix-data column-below-pivot)
        0
        0
        0))
      (matrix-rows matrix))))
</pre>
</div>

<p>
So if <b>G<sub>n</sub></b> were the <i>elementary lower-triangular matrices</i> from the last section that performed our eliminations and <b>F<sub>n</sub></b> are the new <b>Type I</b> pivot adjustments then if we adjust our pivot before each elimination, our reduction needs to be rewritten as <b>G<sub>1</sub>F<sub>1</sub>G<sub>2</sub>F<sub>2</sub>..G<sub>r</sub>F<sub>r</sub>A=U</b> where each <b>G</b> <b>F</b> pair corresponds to a reduction of a column: <b>(G<sub>1</sub>F<sub>1</sub>)<sub>col<sub>1</sub></sub>(G<sub>2</sub>F<sub>2</sub>)<sub>col<sub>2</sub></sub>..(G<sub>r</sub>F<sub>r</sub>)<sub>col<sub>r</sub></sub>A=U</b>. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-reduce-column</span> (matrix column-to-reduce)
  <span style="color: #cc0000;">"Adjusts the pivot using partial pivoting and eliminates the elements in one column. Returns a list of the elimination matrix, permutation matrix and the resulting matrix with reduced column (list of 3 matrices)"</span>
  (<span style="color: #00af00;">let*</span>
      ((pivot-adjusting-matrix
        (matrix-partial-pivot
         matrix
         column-to-reduce) )
       (matrix-with-partial-pivoting
        (matrix-product <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">pivot!</span>
         pivot-adjusting-matrix
         matrix))
       (column-elimination-matrix
        (matrix-elementary-lower-triangular
         matrix-with-partial-pivoting
         column-to-reduce))
       (matrix-with-reduced-column
        (matrix-product <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">reduce</span>
         column-elimination-matrix
         matrix-with-partial-pivoting)))
    (list column-elimination-matrix pivot-adjusting-matrix matrix-with-reduced-column)))

(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-to-upper-triangular</span> (matrix)
  <span style="color: #cc0000;">"Take the input MATRIX and use Gaussian elimination to make the upper triangular back-substitution matrix"</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-to-upper-triangular-rec</span> (matrix column-to-reduce)
    (<span style="color: #00af00;">cond</span>
     ((equal
       column-to-reduce
       (matrix-rows matrix))
      matrix)
     (t
      (matrix-to-upper-triangular-rec
       (third (matrix-partial-pivot-and-reduce-column matrix column-to-reduce))
       (1+ column-to-reduce)))))
  (matrix-to-upper-triangular-rec matrix 0))
</pre>
</div>
<blockquote>
<p>
<b>TODO</b>: Return <b>G<sup>-1</sup></b> instead, because it's more directly what we need later
</p>
</blockquote>

<p>
Turning back to our orginal <b>Ax=b</b> we can again generate the <b>b<sub>new</sub></b>: <b>Ux=(G<sub>1</sub>F<sub>1</sub>)<sub>col<sub>1</sub></sub>(G<sub>2</sub>F<sub>2</sub>)<sub>col<sub>2</sub></sub>..(G<sub>r</sub>F<sub>r</sub>)<sub>col<sub>r</sub></sub>b</b> -&gt; <b>Ux=b<sub>new</sub></b>. Then again using back substitution we can get a solution for <b>x</b>. However this solution has some flaws. When looking at <b>(G<sub>1</sub>F<sub>1</sub>)<sub>col<sub>1</sub></sub>(G<sub>2</sub>F<sub>2</sub>)<sub>col<sub>2</sub></sub>..(G<sub>r</sub>F<sub>r</sub>)<sub>col<sub>r</sub></sub></b> we can no longer just copy together factors - even if we invert and reorder the matrices. The result is messy and involves a lot of products and calculations. Before we added the pivots in, we had manage to get a clean equation <b>A=LU</b>, and <b>L</b> was especially easy to make without carrying out a single matrix product - but now building that decomposition suddenly isn't as easy!
</p>
</div>
</div>

<div id="outline-container-sec-6-1-4" class="outline-4">
<h4 id="sec-6-1-4">Extracting the pivots</h4>
<div class="outline-text-4" id="text-6-1-4">
<p>
On <i>page 150</i> the book shows us how we can fix this situation by extracting the partial pivots out of column reductions so that instead of: <b>G<sub>1</sub>F<sub>1</sub>G<sub>2</sub>F<sub>2</sub>..G<sub>r</sub>F<sub>r</sub>A=U</b> we are left with something that looks more like  <b>G<sub>1</sub>G<sub>2</sub>..G<sub>r</sub>F<sub>1</sub>F<sub>2</sub>..F<sub>r</sub>A=U</b>. With the <b>G</b>'s together we can move them back over to the other side to get our easily-computed <b>L</b> back. Taking the product of the <b>F</b>'s gives us a new <i>permutation matrix</i> <b>P</b> so that our final equation will look like <b>PA=LU</b>. Looking from a different perspective, the reason we've had the matrices interleaved is because that's how we build them (from right to left). We can't go into the middle of the matrix and adjust the pivot position till we'd carried out all the eliminations in the columns before it. The previous eliminations will mix up the rows and change all the values in that column so the maximal value won't be known ahead of time. So the <i>GFGFGF</i> sequence for building the reduction matrices (from right to left, column by column)  needs to be observed. However once we've finished Gaussian elimination then we know the final order of the rows in <b>U</b>. And what <i>page 150</i> demonstrates is that if we know the row interchanges, we can actually carry them out first as long as we then fix-up any <i>preceding</i> eliminations matrices a bit. Specifically if you adjust some pivot <i>k</i> by swapping it with row <i>k+i</i> then any <i>previous</i> eliminations that involved the row <i>k</i> (and row <i>k+i</i>) now needs to be fixed to reflect that you'll be doing the row interchange ahead of time.
</p>

<p>
While the <b>G<sub>1</sub>G<sub>2</sub>..G<sub>r</sub>F<sub>1</sub>F<sub>2</sub>..F<sub>r</sub>A=U</b> representation is really handy, we would like to build matrices as-we-go and not have to build the interleaved mess and then have to spend time fixing it.
</p>

<p>
The strategy is that as we <i>pivot adjust</i> and <i>eliminate</i> and <i>pivot</i> and <i>eliminate</i> column by column, slowly building up our <b>U</b> matrix, each time we <i>pivot adjust</i> we build our permuation matrix <b>P</b> by accumulating the products of the <b>F</b>'s and we fix-up the preceeding eliminations some how. The way it's described in the book, they seem to update all the <b>G</b> matrices that came before - however in practice it's much easier to skip all the <b>G</b>'s and go straight to building the <b>L</b> matrix and to adjust the rows there. We cand do that by taking every <b>G</b> we get during elimination inverting it to <b>G<sup>-1</sup></b> and add it to <b>L</b> so that <b>L<sub>new</sub> = L<sub>old</sub>G<sup>-1</sup></b>. And then each time we adjust a pivot with a new <b>F</b> we update <b>L</b> such that <b>L<sub>new</sub>=FL<sub>old</sub>F</b>.
</p>

<blockquote>
<p>
To see why this is equivalent to updating all the <b>G</b>'s and then inverting at the end, rememeber that <b>F=F<sup>-1</sup></b> b/c a row exchange is it's own inverse. So <b>F<sup>2</sup>=I</b>. So if we have are in the middle of Gaussian elimination and have <b>G<sub>3</sub>G<sub>2</sub>G<sub>1</sub>A=U</b> and we then  do a pivot adjustment <b>FG<sub>3</sub>G<sub>2</sub>G<sub>1</sub>A=U</b> then we can insert a identity matrix <b>FG<sub>3</sub>G<sub>2</sub>G<sub>1</sub>IA=U</b> expand it to <b>FF</b> so that <b>FG<sub>3</sub>G<sub>2</sub>G<sub>1</sub>FFA=U</b> then bring everything to the other side <b>FA=F<sup>-1</sup>G<sub>1</sub><sup>-1</sup>G<sub>2</sub><sup>-1</sup>G<sub>3</sub><sup>-1</sup>F<sup>-1</sup>U</b> recover our easy-to-compute <b>L</b> matrix <b>FA=F<sup>-1</sup>LF<sup>-1</sup>U</b> simplify our <b>F<sup>-1</sup></b>'s so that <b>FA=FLFU</b> and we have our new <b>L</b> in <b>FA=L<sub>new</sub>U</b>
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-update-L-matrix</span> (elementary-lower-triangular-matrix type-i-interchange-matrix)
  <span style="color: #cc0000;">"Take an elementary lower triangular matrix and update it to match a row interchange between ROW1 and ROW2 (ZERO indexed)"</span>
    (matrix-product
     type-i-interchange-matrix
     (matrix-product
      elementary-lower-triangular-matrix
      type-i-interchange-matrix)))
</pre>
</div>
<blockquote>
<p>
<b>TODO</b>: Update to not do two full matrix products. This can be do with some clever number swapping instead
</p>
</blockquote>

<p>
So our method will still go reducing the matrix column by column and building up <b>U</b>, but in parallel we will be building <b>L</b> and <b>P</b>. So the result will be the three matrices (<b>P</b> <b>L</b> <b>U</b>).
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-LU-decomposition</span> (matrix)
  <span style="color: #cc0000;">"Perform Gaussian elimination with partial pivoting on MATRIX and return the list (P L U), representing the LU-decomposition "</span>
  (<span style="color: #00af00;">let</span>
      ((rank
        (matrix-rows matrix)))
    (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-LU-decomposition-rec</span> (P-matrix
                                        L-matrix
                                        reduced-matrix
                                        column-to-reduce)
      (<span style="color: #00af00;">cond</span>
       ((equal
         column-to-reduce
         rank)
        (list P-matrix L-matrix  reduced-matrix))
       (t
        (<span style="color: #00af00;">let</span>
            ((current-column-reduction-matrices
              (matrix-reduce-column
               reduced-matrix
               column-to-reduce)))
          (matrix-LU-decomposition-rec
           (matrix-product                              <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">update the permutation matrix</span>
            (second current-column-reduction-matrices)
            P-matrix)
           (matrix-product
            (matrix-update-L-matrix       <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">update elimination matrices due to partial pivot</span>
             L-matrix
             (second current-column-reduction-matrices))
            (matrix-invert-elementary-lower-triangular (first current-column-reduction-matrices)))
           (third current-column-reduction-matrices)    <span style="color: #b2b2b2; font-style: italic;">; </span><span style="color: #b2b2b2; font-style: italic;">the further reduced matrix</span>
           (1+ column-to-reduce))))))

    (matrix-LU-decomposition-rec
     (matrix-identity rank)
     (matrix-identity rank)
     matrix
     0)))
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Using the LU</h2>
<div class="outline-text-2" id="text-7">
<blockquote>
<p>
<b><i>Notes on getting a good numerical solution:</i></b>
</p>

<p>
<i>Section 1.5</i> goes into a good amount of detail of why floating point arithmetic will introduce errors and how to mitigate the problem. Partial pivoting will provide a bit of help, however it's also suggested to use <b>row-scaling</b> and <b>column-scaling</b>.
</p>

<p>
<b>Row-scaling</b> will alter the magnitude of the output value of your linear system, while <b>column scaling</b> will alter the scale of your inputs. Don't hesitate to have the inputs and outputs use different units. <i>page 28</i> suggests scaling the rows such that the maximum magnitude of each row is equal to <b>1</b> (ie. divide the row by the largest coefficient)
</p>

<p>
The topic of <i>residuals</i>, <i>sensitivity</i> and <i>coditioning</i> will be revisited later
</p>
</blockquote>
</div>


<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">Solving for x in Ax=b</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Now that we can break a linear system <b>A</b> into two systems <b>L</b> and <b>U</b> we need to go back to where we started and solve for inputs given some outputs.We started with <b>Ax=b</b> and now we know we can do <b>PA=LU</b>. Combinding the two we can get <b>PAx=Pb</b> and then <b>LUx=Pb</b>. As mentioned before, <b>b<sub>new</sub>=Pb</b>, so for simplicity <b>LUx=b<sub>new</sub></b>. The new <b>b</b> has the same output values, just reordered a bit due to pivot adjustments. Since the order of the original equations generally doesn't have a special significance this is just a minor change.
</p>

<p>
Next we define a new intermediary vector <b>Ux=y</b> so that we can write <b>Ly=b<sub>new</sub></b>. This value we can solve directly by forward substitution. The first row of the lower triangular matrix gives us a simple solvable equation of the form <b>ax=b</b> and every subsequent row adds an additional unknown that we can solve for directly.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-forward-substitution</span> (lower-triangular-matrix output-vector)
  <span style="color: #cc0000;">"Solve for an input-vector using forward substitution. ie. solve for x in Lx=b where b is OUTPUT-VECTOR and L is the LOWER-TRIANGULAR-MATRIX"</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-forward-substitution-rec</span> (lower-triangular-matrix input-vector-data output-vector-data row)
    (<span style="color: #00af00;">cond</span>
     ((null output-vector-data) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">BASE CASE</span>
      input-vector-data)
     (t                         <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">REST</span>
      (matrix-forward-substitution-rec
       lower-triangular-matrix
       (append
        input-vector-data
        (list
         (/
          (-
           (car output-vector-data)
           <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">on the first iteration this is the product of null vectors.. which in our implementation returns zero</span>
           (matrix-inner-product-data
            (matrix-data
             (matrix-extract-subrow
              lower-triangular-matrix
              row
              0
              row))
            input-vector-data))
          (matrix-get-value lower-triangular-matrix row row))))
       (cdr output-vector-data)
       (1+ row)))))

  (matrix-from-data-list
   (matrix-rows lower-triangular-matrix)
   1
   (matrix-forward-substitution-rec
    lower-triangular-matrix
    '()
    (matrix-data output-vector)
    0)))
</pre>
</div>



<p>
Once we have <b>y</b> we can go to <b>Ux=y</b> and solve for <b>x</b> by back substitution
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-back-substitution</span> (upper-triangular-matrix output-vector)
  <span style="color: #cc0000;">"Solve for an input-vector using forward substitution. ie. solve for x in Lx=b where b is OUTPUT-VECTOR and L is the LOWER-TRIANGULAR-MATRIX"</span>
  (matrix-from-data-list
   (matrix-rows upper-triangular-matrix)
   1
   (nreverse
    (matrix-data
     (matrix-forward-substitution
      (matrix-from-data-list
       (matrix-rows upper-triangular-matrix)
       (matrix-rows upper-triangular-matrix) <span style="color: #b2b2b2; font-style: italic;">;; </span><span style="color: #b2b2b2; font-style: italic;">rows == columns</span>
       (nreverse (matrix-data upper-triangular-matrix)))
      (matrix-from-data-list
       (matrix-rows output-vector)
       1
       (nreverse (matrix-data output-vector))))))))
</pre>
</div>
<blockquote>
<p>
<b>Not</b>: Here I'm using a bit of a trick to reuse the forward substitution function
</p>
</blockquote>

<p>
Now glueing everything together is now just a few lines of code
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-solve-input</span> (matrix output-vector)
  <span style="color: #cc0000;">"Solve for an input-vector using forward substitution. ie. solve for x in Lx=b where b is OUTPUT-VECTOR and L is the LOWER-TRIANGULAR-MATRIX"</span>
  (<span style="color: #00af00;">let*</span> ((LU-decomposition (matrix-LU-decomposition matrix))
         (permuted-output-vector (matrix-product (first LU-decomposition) output-vector))
         (intermediate-y-vector (matrix-forward-substitution (second LU-decomposition) permuted-output-vector)))
    (matrix-back-substitution (third LU-decomposition) intermediate-y-vector)))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">The LDU Decomposition</h3>
<div class="outline-text-3" id="text-7-2">
<p>
As mention on <i>page 154</i>, the <b>LU</b> can be further broken down into <b>LDU</b> - where both <b>L</b> and <b>U</b> have <b>1</b>'s on the diagonal and <b>D</b> is a diagonal matrix with all the pivots. This has the nice property of being more symmetric.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-LDU-decomposition</span> (matrix)
  <span style="color: #cc0000;">"Take the LU decomposition and extract the diagonal coefficients into a diagonal D matrix. Returns ( P L D U ) "</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-extract-D-from-U</span> (matrix)
    <span style="color: #cc0000;">"Extract the diagonal coefficients from an upper triangular matrix into a separate diagonal matrix. Returns ( D U ). D is diagonal and U is upper triangular with 1's on the diagonal"</span>
    (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-build-D-U-data</span> (matrix row D-data U-data)
      (<span style="color: #00af00;">let</span> ((rank (matrix-rows matrix))
            (pivot (matrix-get-value matrix row row)))
        (<span style="color: #00af00;">cond</span> ((equal row rank)
               (list D-data U-data) )
              (t
               (matrix-build-D-U-data
                matrix
                (1+ row)
                (nconc
                 D-data
                 (matrix-data
                  (matrix-scalar-product
                   (matrix-unit-row row rank)
                   pivot)))
                (nconc
                 U-data
                 (matrix-unit-rowcol-data row (1+ row))
                 (matrix-data
                  (matrix-scalar-product
                   (matrix-extract-subrow matrix row (1+ row) rank)
                   (/ 1 pivot)))))))))

    (<span style="color: #00af00;">let</span> ((rank (matrix-rows matrix))
          (D-U-data (matrix-build-D-U-data matrix 0 '() '())))
      (list
       (matrix-from-data-list rank rank (first D-U-data))
       (matrix-from-data-list rank rank (second D-U-data)))))

  (<span style="color: #00af00;">let</span> ((LU-decomposition (matrix-LU-decomposition matrix)))
    (nconc
     (list
      (first LU-decomposition)
      (second LU-decomposition))
     (matrix-extract-D-from-U
      (third LU-decomposition)))))
</pre>
</div>
<p>
An extra nicety is that if <b>A</b> is symmetric then <b>A=A<sup>T</sup></b> and therefore <b>LDU=(LDU)<sup>T</sup>=U<sup>T</sup>D<sup>T</sup>L<sup>T</sup></b>. Since <b>D==D<sup>T</sup></b> and the <b>LU</b> factorization is unique then <b>L</b> must equal <b>U<sup>T</sup></b> and <b>U</b> is equal to <b>L<sup>T</sup></b> - so we can write <b>A=LDL<sup>T</sup></b>
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-is-symmetric</span> (matrix)
  <span style="color: #cc0000;">"Test if the matrix is symmetric"</span>
  (<span style="color: #00af00;">let</span> ((transpose (matrix-transpose matrix)))
    (<span style="color: #00af00;">let</span> ((A-data (matrix-data matrix))
          (A-transpose-data (matrix-data transpose)))
      (equal A-data A-transpose-data))))
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">The Cholesky Decomposition</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Going one step further - if we have a symmetric matrix (so <b>A=LDL<sup>T</sup></b>) and all the pivots are positive, then we can break up the <b>D</b>  into 2 further matrices <b>D<sub>split</sub></b>. The <b>D<sub>split</sub></b> matrix will be like <b>D</b>, but instead each element on the diagonal (the pivots from the original <b>U</b> matrix) will be replaced by its square root - so that <b>D<sub>split</sub>D<sub>split</sub>=D</b>. This is taking advantage of the fact that a unit diagonal multiplied with itself simply squares the diagonal elements. Note here that if any of the diagonal elements are negative, then you can't really take the square root here b/c you'd get complex numbers.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-is-positive-definite</span> (matrix)
  <span style="color: #cc0000;">"Test if the matrix is symmetric"</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">is-no-data-negative</span> (data)
    (<span style="color: #00af00;">cond</span> ((null data) t)
          ((&lt; (car data) 0) nil)
          (t (is-no-data-negative (cdr data)))))

  (<span style="color: #00af00;">let*</span> ((PLDU (matrix-LDU-decomposition matrix))
         (D (third PLDU)))
    (<span style="color: #00af00;">and</span> (matrix-is-symmetric matrix) (is-no-data-negative (matrix-data D)))))
</pre>
</div>

<p>
But if the pivots are positive, then we change <b>A=LDL<sup>T</sup></b> to <b>A=LD<sub>split</sub>D<sub>split</sub>L<sup>T</sup></b>. Notice that both halfs of the equation are similar. Remember that just like with <b>D</b>, <b>D<sub>split</sub>=D<sub>split</sub><sup>T</sup></b>. So we can rewrite <b>A=LD<sub>split</sub>D<sub>split</sub>L<sup>T</sup></b> as <b>A=LD<sub>split</sub>D<sub>split</sub><sup>T</sup>L<sup>T</sup></b>. Assigning a new matrix <b>R</b> to be equal to the product <b>LD<sub>split</sub></b> we can write down <b>A=RR<sup>T</sup></b>. This <b>R</b> will have the square root elements on the diagonal b/c <b>L</b> has <b>1</b>'s on its central diagonal. The text then demonstates that since <b>R=LD<sub>split</sub></b> is reversible and unique, that given <b>A=RR<sup>T</sup></b> where <b>R</b> has positive diagonal elements, you can reconstruct the <b>LDU</b> decomposition and see that the pivots are positive (the squares of the diagonal elements in your <b>R</b>).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-cholesky-decomposition</span> (matrix)
  <span style="color: #cc0000;">"Take the output of the LDU-decomposition and generatethe Cholesky decomposition matrices"</span>
  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">sqrt-data-elements</span> (data)
    <span style="color: #cc0000;">"Takes a data vector and squares every element and returns the list"</span>
    (<span style="color: #00af00;">cond</span> ((null data) '())
          (t
           (cons
            (sqrt (car data))
            (cdr data)))))

  (<span style="color: #00af00;">let*</span> ((PLDU (matrix-LDU-decomposition matrix))
         (L (second PLDU))
         (D (third PLDU))
         (D_sqrt (matrix-from-data-list
                  (matrix-rows D)
                  (matrix-rows D)
                  (sqrt-data-elements (matrix-data D)))))
    (matrix-product L D_sqrt)))
</pre>
</div>
<blockquote>
<p>
<b>TODO:</b> This (and the <i>positive-definite</i> check above) need some fixing. You can't do partial pivoting b/c <b>PA</b> is no longer symmetric so everything falls apart. This needs a version of <code>matrix-LDU-decomposition</code> and <code>matrix-LU-decomposition</code> that does not pivoting &#x2026; or I need to find a work around that uses the <b>P</b> matrix.
</p>
</blockquote>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Solving for A<sup>-1</sup></h3>
<div class="outline-text-3" id="text-7-4">
<blockquote>
<p>
<b>TODO</b> : page 148
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">TODOs</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>Write a better example that I can expand on easily later
</li>
<li>matrix-update-elimination-matrix could be optimized to not do any matrix products
</li>
<li>The LU Decomp can all be done with no matrix-products.. :/
</li>
<li>Compute <b>A<sup>-1</sup></b> using the <b>LU</b> decomp (see page 148)
</li>
<li>Implement the Sherman-Morrison update formula
</li>
<li>Sensitivity/Condition numbers needs to be revisited and expanded on (page 126-128)
</li>
<li>Do exercise 3.8.8
</li>
<li>Add some kind of mechanism to bail-out when the input matrix isn't singular in the LU
</li>
<li>It's unclear if Cholesky works with partial pivoting
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">SRC<sub>Block</sub> template</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">

<pre class="src src-emacs-lisp">  (<span style="color: #00af00;">defun</span> <span style="color: #ef2929;">matrix-template</span> (matrix)
<span style="color: #cc0000;">"template"</span>
)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">End</h2>
<div class="outline-text-2" id="text-10">
<blockquote>
<p>
This webpage is generated from an org-document (at <code>./index.org</code>) that also generates all the files described. 
</p>

<p>
Once opened in Emacs:<br  />
</p>
<ul class="org-ul">
<li><code>C-c C-e h h</code> generates the webpage  <br  />
</li>
<li><code>C-c C-v C-t</code> exports the code blocks into the appropriate files<br  />
</li>
</ul>
</blockquote>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: George Kontsevich</p>
<p class="date">Created: 2018-01-19 Fri 16:31</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 25.2.2 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
