#+TITLE: Linear Systems in Lisp
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://geokon-gh.github.io/static/worg.css" />
#+options: num:nil
# This will export a README.org file for Github, so that people that land in my repo know where to find the relevant webpage
#+BEGIN_SRC org :tangle README.org :exports none
  see description [[http://geokon-gh.github.io/linearsystems/index.html][here]]
#+END_SRC

* Intro
I'm going through [[matrixanalysis.com][Matrix Analysis & Applied Linear Algebra]] (Carl Meyer)  and implementing the algorithms in ELisp. An excuse to learn ELisp and solidy my linear algebra. There is no emphasis on performance - just on clarity and extensability

* Matices
Linear system (ie. a system of equations) are for convenience represented using matrices. Once we define a matrix and all operations on it we can begin to use them for manipulating linear systems. The standard way of representing a matrix that you often see in C is using multidimensional arrays. For a 2D matrix this has 3 values: ~number of rows~ ~number of columns~ ~values~

The values are a long list of data of size ~num-row * num-col~. When making a new matrix it's useful to be able to make a list of zeroes of the required size
#+BEGIN_SRC emacs-lisp :results output :session :tangle matrix.el
  (defun build-list-of-zeroes (size)
    "Recursively builds a list of zeroes of the given size"
    (if (zerop size) 
        '() ;base case
      (cons 0 (build-list-of-zeroes (- size 1))))) ; "else"/iterative step
#+END_SRC
#+BEGIN_QUOTE
~zerop~ tests if the values is zero
#+END_QUOTE
#+BEGIN_QUOTE
~()~ with a quote is the /empty-list/ 
#+END_QUOTE
#+BEGIN_QUOTE
~cons~ attaches the first argument to the second argument (which is normally a list)
#+END_QUOTE

Now we can build the actual matrix
#+BEGIN_SRC emacs-lisp :results output :session :tangle matrix.el
  (defun matrix-zeroes (number-of-rows number-of-columns)
    "Builds a matrix of zeroes"
    (list 
     number-of-rows 
     number-of-columns 
     (build-list-of-zeroes (* number-of-rows number-of-columns))))
#+END_SRC
#+BEGIN_QUOTE
~list~ build a list of values equivalent to ~(cons number-of-rows (cons number-of-columns (cons (build-list-of-zeroes ...) '() )))~ *(note the last /empty-list/ element)*
#+END_QUOTE
Similarly we would like to be able to build lists of random integers
#+BEGIN_SRC emacs-lisp :results output :session :tangle matrix.el
  (defun build-list-of-random-digits (size)
    "Recursively builds a list of zeroes of the given size"
    (if (zerop size) 
        '() ;base case
      (cons (random 10) (build-list-of-random-digits(- size 1)))))

  (defun matrix-random-digits (number-of-rows number-of-columns)
    "Builds a matrix of zeroes"
    (list 
     number-of-rows 
     number-of-columns 
     (build-list-of-random-digits (* number-of-rows number-of-columns))))

  ; ex: (matrix-random-digits 2 3)
#+END_SRC
And list from manually entered values
#+BEGIN_SRC emacs-lisp :results output :session :tangle matrix.el

  (defun matrix-from-values (number-of-rows number-of-columns values)
    "Builds a matrix of zeroes"
    (list 
     number-of-rows 
     number-of-columns 
     values))
#+END_SRC
For debugging we need to be able to print out the matrix for inspection
#+BEGIN_SRC emacs-lisp :results output :session :tangle matrix.el
  (defun get-first-n-values (values n)
      "Given a list of values, get the first n in a string"
      (if (zerop n)
          "" ;base case
        (concat
         (number-to-string (car values))
         " "
         (get-first-n-values (cdr values) (- n 1)))))

  (defun print-values (number-of-rows number-of-columns values)
    "Print out values gives the dimension of the original matrix"
    (if (zerop number-of-rows)
        ""
      (concat
       (get-first-n-values values number-of-columns)
       "\n"
       (print-values
        (- number-of-rows 1)
        number-of-columns
        (nthcdr number-of-columns values )))))

  (defun matrix-print (matrix)
    "Print out the matrix"
    (let
        ((number-of-rows (nth 0 matrix))
         (number-of-columns (nth 1 matrix))
         (values (nth 2 matrix)))
      (concat "\n" (print-values
                       number-of-rows
                       number-of-columns
                       values))))
; ex:  (message (matrix-print (matrix-from-values 2 2 '(1 2 3 4))))
#+END_SRC
#+BEGIN_QUOTE
~nth~ gets the nth element of the list
#+END_QUOTE
#+BEGIN_QUOTE
~cdr~ returns the list without the first element
#+END_QUOTE
* Matrix Operations
Next we need to define some basics operations on the martices
** Addition
The simplest operation is addition. We need to check the matrices have the right size and then simple add the ~values~ lists
#+BEGIN_SRC emacs-lisp :results output :session :tangle matrix.el
  (defun matrix-equal-size? (matrix1 matrix2)
    (and
     (equal
      (nth 0 matrix1)
      (nth 0 matrix2))
     (equal
      (nth 1 matrix1)
      (nth 1 matrix2))))
  (defun for-each-pair (list1 list2 operator)
    (if (null list1)
        '()
      (cons
       (funcall operator (car list1) (car list2))
       (for-each-pair (cdr list1) (cdr list2) operator))))

  (defun matrix-add (matrix1 matrix2)
    (if (check-addition matrix1 matrix2)
        (matrix-from-values
         (nth 0 matrix1)
         (nth 1 matrix1)
         (for-each-pair
          (nth 2 matrix1)
          (nth 2 matrix2)
          '+))))
#+END_SRC
#+BEGIN_QUOTE
~funcall~ applied the first arugment (a function) with the remaining items in the list as arguments
#+END_QUOTE
This webpage is generated from an org-document (at ~./index.org~) that also generates all the files described. 

Once opened in Emacs:\\
- ~C-c C-e h h~ generates the webpage  \\
- ~C-c C-v C-t~ exports the code blocks into the appropriate files\\
#+END_QUOTE
